{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>EdgeFarm is currently under heavy construction</p> <p>EdgeFarm is currently under active development and the corresponding components are being released gradually. Accordingly, the documentation is not yet complete. The functionalities described in the documentation refer to the final state after the release of all functions.</p> <p></p>"},{"location":"#what-is-edgefarm","title":"What is EdgeFarm","text":"<p>Seamless edge computing</p> <p>EdgeFarm is an open source cloud native development platform for edge- and hybrid applications where application assets can be freely moved between edge and cloud. Hybrid applications refer to applications that are partially deployed on edge devices and partially in the cloud.</p> <p>Edgefarm is heavily based on Kubernetes. EdgeFarm extends Kubernetes with a bunch of great open source projects. EdgeFarm selectively combines and extends these to provide a platform that offers the same comfort of native cloud development.</p> <p>EdgeFarm extends Kubernetes to provide the following functions:</p> <ul> <li>dynamic and secure registration of edge nodes (edgefarm.core)</li> <li>life cycle management of edge node firmware (edgefarm.devices)</li> <li>life cycle management of edge- or hybrid applications (edgefarm.applications)</li> <li>reliable communication with data retention in the event of network loss and providing secure access of  third party systems (edgefarm.network)</li> <li>monitoring the whole stack (edgefarm.monitor)</li> </ul> <p>... all done in a cloud native way.</p>"},{"location":"#why-edgefarm","title":"Why EdgeFarm?","text":"<p>How great would it be if you could write edge software just like cloud software for your Kubernetes based cloud backend? You'd be free to try out a new piece of software nearly effortless, you'd have access to a huge pool of open source software, you could use your existing CD/CD system to roll out your edge software, and so on.</p> <p>But edge computing differs from cloud computing in one fundamental way. While compute power in the cloud can be scaled automatically at any time, edge devices are tied to specific locations and replacements or upgrades must be done manually on site. This means that network failures or outages cannot simply be bridged by redundancies and taken over by other compute resources.</p> <p>This results in the requirement that egde devices must be able to run autonomously over a longer period of time and that the acquired data must be buffered until the connection is restored.</p> <p>All software used on the edge devices must be able to handle unreliable network connections and synchronize with the backend system when the connection is restored.</p> <p>If this was solved and my Edge device behaved like another Kubernetes node handling unreliable connections, it would make my day-to-day life as a programmer much more pleasant.</p> <p>And that is why EdgeFarm is being developed.</p> <p>As a side note, EdgeFarm is GitOps ready. Commit your changes to your Git repository and let the CD system do the rest. You find more information about GitOps here. </p>"},{"location":"bestpractices/","title":"Index","text":"<p>Under Construction</p>"},{"location":"bestpractices/secret-handling/","title":"HOWTO handle secrets","text":"<p>sealed-secrets is a great solution to store Kubernetes (the base of EdgeFarm) secrets in source code management systems like git.</p> <p>The big advantage is that sealed-secrets can be added to EdgeFarm in any way, either directly using kubectl or via a CI/CD system, but none of the systems need a key to the secrets (as in other solutions such as SOPS). Only the cluster owns the key and converts the sealed-secret back into a Kubernetes secret, usable by your applications and processing pipelines.</p> <p>That is why sealed-secrets is installed by default with EdgeFarm.</p> <p>In the following steps, a \"Sealed Secret\" is created from a Kubernetes Secret. This sealed secret contains only encrypted information and can be checked in without any problems. Only the sealed-secret operator installed in EdgeFarm has the necessary key to convert the sealed secret back into a Kubernetes secret. The actual Kubernetes secret is not published anywhere.</p> <p>It is important to understand that data encrypted using sealed-secrets can only be decrypted by the EdgeFarm instance that performed the encryption. It is not possible to move sealed-secrets back and forth between different EdgeFarm instances.</p> <p>sealed-secrets does not serve as a \"root of trust\". sealed-secrets is rather an exta layer of securitiy and simplifies the deployment process. Tools such as SOPS are suitable for storing also the \"raw\" secrets in a source code management system.</p>"},{"location":"bestpractices/secret-handling/#prerequisites","title":"Prerequisites","text":"<ul> <li>Your current kube-context must point to the EdgeFarm cluster, where you   want to store the secrets in.</li> <li>actual version of   kubeseal   needs to be installed into your system.</li> </ul>"},{"location":"bestpractices/secret-handling/#step-1-create-a-kubernetes-secret","title":"Step 1: Create a Kubernetes secret","text":"<p>An initial secret can be created in many ways. A very convenient one is kustomize, which is used in the following example.</p> <p>If you want to create your secret from several key-value pairs, placed in one file, see <code>secrets.env</code>.</p> <pre><code>$ cat secrets.env\nkey1=SecretValue1\nkey2=SecretValue2\nkey3=SecretValue3\nkey4=SecretValue4\nkey5=SecretValue5\n</code></pre> <p>If you want to create your secrets from different files containing the whole secret information's, see <code>secret.file</code></p> <pre><code>$ cat secret.file\nmy super secret\nmultiline\ndata\n</code></pre> <p>The two types can also be combined, as illustrated in this example.</p> <p>Now let's generate the secrets. To do this</p> <p>To do this, kustomize is executed in the current folder. First let's look at the definition in <code>kustomization.yaml</code>.</p> <pre><code>apiVersion: kustomize.config.k8s.io/v1beta1\nkind: Kustomization\n\nnamespace: example-namespace-name\n\nsecretGenerator:\n- name: example-secret\n  type: Opaque\n  env: ./secrets.env\n  files:\n  - ./secret.file\ngeneratorOptions:\n disableNameSuffixHash: true\n</code></pre> <p>This controls the generation of the secret. It is important that the correct namespace is selected in which the secret is to exist later.</p> <p>The secretGenerator creates a Kubernetes secret with the name example-secret and uses the <code>secrets.env</code> as well as the <code>secret.file</code> for the creation.</p> <p>To generate the secret, the following command is executed:</p> <pre><code>$kubectl kustomize .\napiVersion: v1\ndata:\n  key1: U2VjcmV0VmFsdWUx\n  key2: U2VjcmV0VmFsdWUy\n  key3: U2VjcmV0VmFsdWUz\n  key4: U2VjcmV0VmFsdWU0\n  key5: U2VjcmV0VmFsdWU1\n  secret.file: bXkgc3VwZXIgc2VjcmV0Cm11bHRpbGluZQpkYXRh\nkind: Secret\nmetadata:\n  name: example-secret\n  namespace: example-namespace-name\ntype: Opaque\n</code></pre> <p>The secret is only output and not stored anywhere. This will be done in the next step.</p> <p>As you can see, all keys under data are taken over into the secret. additionally another secret, named after the filename, is created. All data are base64 encoded and therefore decodable by everyone (NOT secure).</p>"},{"location":"bestpractices/secret-handling/#step-2-convert-secret-to-sealed-secret","title":"Step 2: Convert secret to sealed secret","text":"<p>To convert the secret to a sealed secret, combine the generation command with kubeseal and store the results to <code>example-sealed-secrets.yaml</code>:</p> <pre><code>kubectl kustomize . |  kubeseal --format yaml &gt; example-sealed-secret.yaml\n</code></pre> <p>the resulting file looks like this:</p> <pre><code>apiVersion: bitnami.com/v1alpha1\nkind: SealedSecret\nmetadata:\n  creationTimestamp: null\n  name: example-secret\n  namespace: example-namespace-name\nspec:\n  encryptedData:\n    key1: AgCYsFYdAvfp3VekUjMRaLYZDXybjqwUDAtSbSfUhSkE...\n    key2: ...\n    key3: ...\n    key4: ...\n    key5: ...\n    secret.file: ...\n  template:\n    data: null\n    metadata:\n      creationTimestamp: null\n      name: example-secret\n      namespace: example-namespace-name\n    type: Opaque\n</code></pre> <p>Now, the data are encrypted by sealed-secret and can be stored and used everywhere you want.</p> <p>If you apply the sealed secret to your EdgeFarm instace, a secret will be created in the given namespace and can be used by your workloads, like applications or worker.</p>"},{"location":"bestpractices/secret-handling/#step-3-improvement-prepare-kustomize-to-use-the-sealed-secret","title":"Step 3: Improvement: Prepare kustomize to use the sealed secret","text":""},{"location":"knowledge-base/","title":"Overview","text":"<p>The EdgeFarm Knowledge Base is a collection of documents covering recommended practices and EdgeFarm-related how-tos.</p> <ul> <li> <p> Getting Started</p> <p>Follow the Getting started guide to introduce yourself to EdgeFarm.</p> <p> Getting started</p> </li> <li> <p> Concepts</p> <p>Understand how the components of EdgeFarm work under the hood.</p> <p> Concepts</p> </li> <li> <p>: Tutorials</p> <p>Learn how to use EdgeFarm in practice.</p> <p> Tutorials</p> </li> <li> <p> Reference</p> <p>Find detailed information about EdgeFarm's API, glossary and Well-known Labels, Annotations and Taints.</p> <p> Reference</p> </li> </ul>"},{"location":"knowledge-base/concepts/","title":"Overview","text":"<p>The following architecture descriptions serve as an overview of the components used and the most common interactions between them.</p> <p>It does not claim to be complete. Rather, it is intended to give the reader a rough understanding of what happens under the hood.</p> <p></p>"},{"location":"knowledge-base/concepts/designdecissions/","title":"Design Decissions","text":""},{"location":"knowledge-base/concepts/designdecissions/#strict-separation-into-independent-components","title":"Strict separation into independent components","text":"<p>There is a strict separation between management of the edge nodes (edgefarm.devices), management of the applications (edgefarm.appplications) and the delivery of the application data (edgefarm.network). These components can be used independently and serve as a supplement to existing systems.</p>"},{"location":"knowledge-base/concepts/designdecissions/#linux-as-edge-node-operating-system","title":"Linux as edge node operating system","text":"<p>In recent years, Linux has become the standard for more complex devices. Furthermore, Linux has the largest embedded hardware support, driver support and the most complete open source software stack.</p>"},{"location":"knowledge-base/concepts/designdecissions/#containers-as-a-core-technology","title":"Containers as a core technology","text":"<p>In pure cloud/data center scenarios, container technologies (such as docker) have been well established and have displaced running software directly on the OS stack.</p> <p>The usage of software and services installed directly in the OS is kept to a minimum (drivers, basic services and container runtime) and everything else is run as a container.</p>"},{"location":"knowledge-base/concepts/designdecissions/#kubernetes-as-base-system","title":"Kubernetes as base system","text":"<p>Kubernetes already brings many useful features that EdgeFarm relies on and that can be used within EdgeFarm.</p> <p>Functions such as declarative setup, secure authorization, application lifecycle management, storage management, redudancy, etc. are available out of the box and only need to be adapted by EdgeFarm.</p>"},{"location":"knowledge-base/concepts/designdecissions/#strict-separation-between-device-firmware-and-application","title":"Strict separation between device firmware and application","text":"<p>Classically, applications on edge devices are distributed together with the firmware of the device. But this has some disadvantages:</p> <ul> <li>Updates take a long time</li> <li>The amount of data to be transferred is difficult to reduce</li> <li>Application development is difficult to separate from firmware development.</li> </ul> <p>EdgeFarm addresses this disadvantages by strictly separating the device firmware from the applications and allowing different groups of users to deploy and operate applications independently from the device software.</p> <p>The functionality contained in the device firmware is kept to a minimum.</p>"},{"location":"knowledge-base/concepts/designdecissions/#compatible-with-different-platforms-and-architectures","title":"Compatible with different platforms and architectures","text":"<p>EdgeFarm is developed to support as many edge hardware as possible and to avoid dependencies to the underlying Linux OS as much as possible.</p> <p>EdgeFarm is developed from the start to support arm64 and amd64 architectures.</p>"},{"location":"knowledge-base/concepts/designdecissions/#declarative-setup-of-all-components","title":"Declarative setup of all components","text":"<p>Declarative setup in the form of manifest files have become established since the dominance of Kubernetes.</p> <p>Here, the target state is defined in the form of .yaml manifests and made available to the system. The system takes care that the defined target state is established. The system configuration can be administered with it e.g. comfortably over git repositories, versioned, reviewed and in the case of error also again rolled back. This approach is called GitOps.</p> <p>EdgeFarm adapts this approach for all system configurations brought in by the user, like firmware, system configurations, device configurations, applications, networks etc.</p>"},{"location":"knowledge-base/concepts/designdecissions/#automation-first-for-all-components","title":"Automation-first for all components","text":"<p>EdgeFarm provides a base for edge or hybrid applications.</p> <p>However, the added value of such an application is usually created outside of EdgeFarm by other application systems that use the derived data to implement e.g. a desktop application for end users.</p> <p>Accordingly, it is important that EdgeFarm can be easily and fully integrated into external development and delivery processes by making all functions available via APIs and offering them secured to these systems.</p>"},{"location":"knowledge-base/concepts/designdecissions/#flexible-hosting","title":"Flexible hosting","text":"<p>The backend is developed without dependencies on cloud providers or other cloud services. The only dependencies are Kubernetes and open source software components.</p> <p>This allows EdgeFarm to be deployed in different scenarios, from public cloud to hybrid cloud to private cloud in your own data center.</p>"},{"location":"knowledge-base/concepts/designdecissions/#open-source","title":"Open Source","text":"<p>Both our own software and all third-party software used in the form of libraries/frameworks are open source.</p> <p>All EdgeFarm components are licensed under open source license (either AGPL V3 or MIT).</p>"},{"location":"knowledge-base/concepts/designdecissions/#independent-of-industrymarket","title":"Independent of industry/market","text":"<p>EdgeFarm solves a generic problem, which exists independently of the industry/market. Accordingly, EdgeFarm does not contain any industry specific code parts and can be used for a wide range of use cases.</p>"},{"location":"knowledge-base/concepts/edgefarm.applications/","title":"edgefarm.applications","text":""},{"location":"knowledge-base/concepts/edgefarm.applications/#0-initial-state","title":"(0) Initial state","text":"<p>KubeVela is configured and up and running and waits on application manifests.</p>"},{"location":"knowledge-base/concepts/edgefarm.applications/#1-deploy-an-application","title":"(1) Deploy an Application","text":"<p>User apply his application, defined by a manifest against the Kubernetes API.</p> <p>KubeVela receives the manifest and converts the definition into argo rollouts ressources. These ressources are pushed against the Kubernetes API and Kubernetes creates the workload on the specific nodes.</p>"},{"location":"knowledge-base/concepts/edgefarm.applications/#23-deploy-an-application-through-git-gitops","title":"(2)(3) Deploy an Application through git (GitOps)","text":"<p>(2)</p> <p>The user needs to tell Argo CD how to access his git repository.</p> <p>From now on, Argo CD watches the repository for changes. If there any chages, Argo CD will pick up the ressouces and push them against the Kubernetes API.</p> <p>(3)</p> <p>The user commits his application mainfest and Argo CD pushes the ressources.</p> <p>The remaining processing is equal to 1.</p>"},{"location":"knowledge-base/concepts/edgefarm.core/","title":"edgefarm.core","text":""},{"location":"knowledge-base/concepts/edgefarm.core/#0-initial-state","title":"(0) Initial state","text":"<p>Cloudcore is set up, valid certificates are stored, and is waiting for edge nodes.</p>"},{"location":"knowledge-base/concepts/edgefarm.core/#123-register-a-new-device","title":"(1)(2)(3) Register a new device","text":"<p>(1)</p> <p>The user issues a new node token from vault. This token is only valid for a specific device.</p> <p>(2)</p> <p>The user transfers the token to the NodeRegistration service of the device, after which the service has a certificate issued by vault and renews it cyclically. The certificates have a very short validity.</p> <p>(3)</p> <p>The certificate is transferred to the egdecore. The edgecore connects to the certificate at the Cloudcore and synchronizes from there on via mtls.</p>"},{"location":"knowledge-base/concepts/edgefarm.core/#4-deploy-workload-on-edge","title":"(4) Deploy workload on edge","text":"<p>After going through the previous steps, it is now possible to deploy workloads to edge devices using standard Kubernetes tools.</p>"},{"location":"knowledge-base/concepts/edgefarm.devices/","title":"Edgefarm.devices","text":"<p>Under Construction</p> <p>In the past we have used mender for the device update.</p> <p>With the rancher elemental-toolkit there is now a very interesting, much more lightweight alternative.</p> <p>As a next step we will evaluate the elemental-toolkit and then adapt and publish our architecture depending on the results.</p>"},{"location":"knowledge-base/concepts/edgefarm.monitor/","title":"edgefarm.monitor","text":""},{"location":"knowledge-base/concepts/edgefarm.monitor/#0-initial-state","title":"(0) Initial state","text":"<p>Monitoring Operator is up an running, waiting on network ressources and watches for workload and nodes with assigned monitoring id.</p> <p>Grafana Mimir is up an running waiting for metrics to store.</p> <p>Grafana Agent is up and running and watches for backend ressouces to monitor.</p> <p>Grafana Web Frontend is up and running. Dashboards for node metrics, networks, applications are preconfigured and a data source to access data from Grafana Mimir is added.</p>"},{"location":"knowledge-base/concepts/edgefarm.monitor/#1-assign-node-to-monitoring-system","title":"(1) Assign node to monitoring system","text":"<p>The User assigns a node to the monitoring system by setting a tag. The Monitoring Operator gets informed about this tag and deploys and setup Grafana Agent on the node.</p> <p>Grafana agent starts immediately to scrape node metrics, which will be contiously transfered to Grafana mimir, using <code>remote_write</code>. Grafana Mimir stores metrics. Grafana Web Frontend receives metrics and visualize them in the Dashboard.</p>"},{"location":"knowledge-base/concepts/edgefarm.monitor/#2-assign-network-to-monitoring-system","title":"(2) Assign network to monitoring system","text":"<p>User assignes a previously created network to the monitoring system.</p> <p>Grafana Agents, both edge and backend, start scraping network informations from the nats servers, provided by edgefarm.network.</p>"},{"location":"knowledge-base/concepts/edgefarm.monitor/#3-assign-workload-to-monitoring-system","title":"(3) Assign workload to monitoring system","text":"<p>User deploys workload with monitoring enabled. The Monitoring Operator gets informed. Grafana Agents on all workload nodes start scraping metrics from this workload.</p>"},{"location":"knowledge-base/concepts/edgefarm.network/","title":"edgefarm.network","text":""},{"location":"knowledge-base/concepts/edgefarm.network/#0-initial-state","title":"(0) Initial state","text":"<p>Network Operator is up and running and waits on Network Ressources and pods with assigned networks. Also Nats and Vault backend services are up and running and Vault continous sync credentials with Nats.</p>"},{"location":"knowledge-base/concepts/edgefarm.network/#1-create-a-network","title":"(1) Create a Network","text":"<p>User creates and apply a network definition with network name, capacities and buffers. Network Operator receive the network definition, creates an account for the network and setup all defined buffers etc.</p>"},{"location":"knowledge-base/concepts/edgefarm.network/#2-assign-node-to-network","title":"(2) Assign node to network","text":"<p>User extend his manifest with a node selector matching his node. Network Operator receive the updated network definition and deploys and configure a Nats Leaf Server to the node.</p> <p>The leaf nats server connects to the backend nats server, all accounts getting synced, and the leaf server is ready to handle data.</p>"},{"location":"knowledge-base/concepts/edgefarm.network/#345-create-workload-with-assigned-network","title":"(3)(4)(5) Create workload with assigned network","text":"<p>(3)</p> <p>User creates and apply a pod and assignes the network id. Kubernetes creates the pod, the network operator gets informed.</p> <p>(4)</p> <p>The network operator creates a user in the network account.</p> <p>(5)</p> <p>The network controller patches the pod and add a dapr sidecar with user credentials. The dapr sitecar connects to the local leaf nats server.</p>"},{"location":"knowledge-base/concepts/edgefarm.network/#6-ready-to-use","title":"(6) ready-to-use","text":"<p>From know on, the pod can use the dapr interface to tranfer his data.</p>"},{"location":"knowledge-base/concepts/overview/components/","title":"EdgeFarm Components","text":"<p>EdgeFarm consists of several independently deployable components, each extending the EdgeFarm system with specific functionalities.</p>"},{"location":"knowledge-base/concepts/overview/components/#kubernetes","title":"Kubernetes","text":"<p>Kubernetes is not an edgefarm component, but the foundation for all components.</p> <p>Kubernetes already brings many useful features that edgefarm relies on and are used within edgefarm.</p> <p>Functions such as declarative setup, secure authorization, application lifecycle management, storage management, redudancy, etc. are available out of the box and only need to be adapted by EdgeFarm.</p>"},{"location":"knowledge-base/concepts/overview/components/#edgefarmcore","title":"edgefarm.core","text":"<p>edgefarm.core extends the Kubernetes cluster with the ability to add edge nodes. This makes it possible to roll out Kubernetes workload to edge devices, the foundation for all other components.</p> <p>In particular, the following functions are available to the user:</p> <ul> <li>secure token-based node authentication</li> <li>node revocation</li> <li>scheduling of any workload on edge nodes</li> <li>retrieve status information from workload</li> </ul> <p>edgefarm.core is made possible by the great open source projects KubeEdge and HashiCorp Vault.</p>"},{"location":"knowledge-base/concepts/overview/components/#edgefarmdevices","title":"edgefarm.devices","text":"<p>Kubernetes itself can manage and update workload on corresponding nodes. The operating system of the node itself must be updated in another way.</p> <p>edgefarm.device extends the Kubernetes cluster with the functionality to update the operating system of the edge nodes, e.g. to update the Linux kernel or to install driver modules.</p> <p>In particular, the following functions are available to the user:</p> <ul> <li>Image signing</li> <li>A/B updates with rollback</li> <li>scheduled rollouts</li> <li>phased rollouts</li> <li>GitOps ready</li> </ul>"},{"location":"knowledge-base/concepts/overview/components/#edgefarmapplications","title":"edgefarm.applications","text":"<p>Kubernetes takes an infrastructure-centric approach to defining workload. Workload is defined by deployments, statefullsets, pods, ingresses, etc., which is very powerful. However, this approach is also tied to a very steep learning curve.</p> <p>edgefarm.applications encapsulates this approach with the help of KubeVela and follows an application-oriented approach.</p> <p>edgefarm.applications is complemented by other great open source projects to implement a fully comprehensive application livecycle management.</p> <p>In particular, the following functions are available to the user:</p> <ul> <li>Application-centric approach</li> <li>Application rollout with rollback</li> <li>sheduled rollouts</li> <li>phased rollouts</li> <li>GitOps ready</li> </ul>"},{"location":"knowledge-base/concepts/overview/components/#edgefarmnetwork","title":"edgefarm.network","text":"<p>Dealing with unreliable networks is not easy and has been solved many times, but at the application level.</p> <p>With edgefarm.network a solution is available that encapsulates the problem and relieves the application developer. The application developer is offered an API that can be utilized to send the data. edgefarm.network then takes care that the data is transferred reliably.</p> <p>edgefarm.network uses the open source project nats under the hood for this, a swiss army knife for messaging.</p> <p>In particular, the following functions are available to the user:</p> <ul> <li>Isolated messaging networks</li> <li>User defined buffer sizes and data retention</li> <li>Dapr-based convenience layer for easy access</li> <li>Secure access from third-party systems</li> </ul>"},{"location":"knowledge-base/concepts/overview/components/#edgefarmmonitor","title":"edgefarm.monitor","text":"<p>At the latest when the devices are installed and the applications are distributed, the user wants to know how the system is doing.</p> <p>edgefarm.monitor provides an out-of-the-box solution that can monitor all assets of the system, including applications and inform the user about error conditions.</p> <p>edgefarm.monitor is based on the great open source Grafana stack. </p> <p>In particular, the following functions are available to the user:</p> <ul> <li>Monitoring of node health</li> <li>Monitoring of application health</li> <li>Monitoring of network capacity</li> <li>Preconfigured Grafana Dashboard</li> <li>Get Alerts on errors</li> </ul>"},{"location":"knowledge-base/concepts/overview/system/","title":"System Overview and Clarification","text":"<p>A typical EdgeFarm setup consists of the following parts.</p> <p></p>"},{"location":"knowledge-base/concepts/overview/system/#backend-system","title":"Backend System","text":"<p>The backend system takes care of all management functions within EdgeFarm. It accepts configurations and takes care of creating the desired state.</p> <p>The backend system, like all other software parts, are managed by Kubernetes. Accordingly, backend functions are accessed via the Kubernetes API. Depending on which EdgeFarm functionalities are installed, the API is extended with corresponding controllers and custom resources (CR).</p> <p>These CR's are then available to EdgeFarm users to implement their functionality.</p> <p>The exact details of the backend functionalities provided are covered in the corresponding components documentation.</p>"},{"location":"knowledge-base/concepts/overview/system/#nodes","title":"Nodes","text":"<p>From Kubernetes Docs:</p> <p>\"Kubernetes runs your workload by placing containers into Pods to run on Nodes. A node may be a virtual or physical machine, depending on the cluster.\"</p> <p>Nodes are the place/the machine/the compute where the applications run. In the case of EdgeFarm, Kubernetes is extended to also support edge devices as Kubernetes nodes on which workloads can be deployed, just like classic nodes.</p> <p>A typical Kubernetes cluster consists of multiple nodes. Any workload can run on these nodes, such as the backend system or the users applications.</p>"},{"location":"knowledge-base/concepts/overview/system/#edge-node","title":"Edge Node","text":"<p>Edge nodes are special nodes, typically running on embedded hardware (but also server hardware) that access or provide information to local resources.</p> <p>Due to their localization, edge nodes have various constraints such as unreliable connections, bandwidth limitations, or compute power limitations that must be dealt with.</p> <p>EdgeFarm extends these nodes with software components that can handle these limitations. These components can be used by the end-user application.</p>"},{"location":"knowledge-base/concepts/overview/system/#compute-node","title":"Compute Node","text":"<p>A typical Kubernetes cluster consists of multiple nodes. Any workload can run on these nodes, such as the backend system or the developed applications.</p> <p>When developing hybrid edge/cloud applications, it is often necessary to outsource certain parts of the application to the cloud, e.g. because certain information needs to be aggregated from different edge devices or because there is not enough computing power available in the edge.</p> <p>Using EdgeFarm, certain cloud nodes can be marked as \"compute nodes\" on which the corresponding application parts can then be rolled out.</p>"},{"location":"knowledge-base/gettingstarted/","title":"Getting started","text":"<p>This guide will help you to get started with EdgeFarm. It will guide you through the process of setting up a local EdgeFarm cluster and deploying your first application.</p> <p>See the navigation on the left to navigate through the guide.</p>"},{"location":"knowledge-base/gettingstarted/example-application/","title":"Basic example application","text":""},{"location":"knowledge-base/gettingstarted/example-application/#the-components","title":"The components","text":"<p>This example shows how a <code>hybrid-application</code> could be defined and deployed. The term <code>hybrid-application</code> means that parts of an application is deployed to cloud nodes and parts of it is deployed on edge nodes. All parts, wherever they are deployed, form the overall application.</p> <p>This example consists of two parts: </p> <ul> <li>A <code>producer</code> that run on one or more edge nodes. It is a very simple application that produces simulated sensor data.</li> <li>A <code>consumer</code> that run on cloud nodes and consume the sensor data. The consumer is a basic web application that can be viewed in a browser.</li> </ul> <p>Both parts are connected to the <code>edgefarm.network</code>. The producer drops the generated data in a stream that is buffered locally on the Edge Node. Note, that the producer can run on many edge nodes, each collecting data individually. As long as the Edge Devices are connected, the consuming part of the network aggregates the data from all Edge Nodes and puts them into another stream running in the cloud. The <code>consumer</code> application reads this stream and provides the data via the web browser.</p> <p>The following picture shows the overall architecture of the example:</p> <p></p>"},{"location":"knowledge-base/gettingstarted/example-application/#the-development","title":"The development","text":"<p>You can use whatever programming language you like to develop your application. This example uses golang for the producer and python for the consumer.</p> <p>The source code of both <code>consumer</code> and <code>producer</code> are located here. Have a look if you are interesested in the details. Both components are published as OCI images to ghcr.io. </p> <p>The <code>consumer</code> and <code>producer</code> OCI images are published as <code>ghcr.io/edgefarm/edgefarm/example-basic-consumer:latest</code> and <code>ghcr.io/edgefarm/edgefarm/example-basic-producer:latest</code> as multi-arch images for amd64 and arm64.</p>"},{"location":"knowledge-base/gettingstarted/example-application/#the-deployment","title":"The deployment","text":"<p>Here you'll learn how the manifests of the <code>producer</code> application and the <code>network</code> are defined. The <code>consumer</code> is a standard Kubernetes deployment and service resource.</p>"},{"location":"knowledge-base/gettingstarted/example-application/#producer-explained","title":"Producer explained","text":"<p>The manifest files are located here.</p> <p>The producer is deployed to the edge nodes. The following snippet shows the edgefarm.applications manifest:</p> <pre><code>apiVersion: core.oam.dev/v1beta1 #(1)!\nkind: Application\nmetadata:\n  name: example-producer #(2)!\nspec:\n  components: #(3)!\n    - name: producer #(4)!\n      type: edgefarm-applications #(5)!\n      properties: \n        image: ghcr.io/edgefarm/edgefarm/example-basic-producer:latest #(6)!\n        nodepoolSelector: #(7)!\n          matchLabels:\n            example: \"producer\" #(8)!\n        name: producer #(9)!\n        cpu: 0.25 #(10)!\n        memory: 256Mi #(11)!\n      traits: #(12)!\n        - type: edgefarm-network  #(13)!\n          properties:\n            network:\n              name: example-network #(14)!\n              subnetwork: edge-to-cloud #(15)!\n              user: publish #(16)!\n</code></pre> <ol> <li>Every application is of <code>kind: Application</code> and <code>apiversion: core.oam.dev/v1beta1</code>.</li> <li>Give your application a meaningful name. This name is used to identify the application resource in the cluster.</li> <li>The <code>components</code> section defines the components that are part of the application. In this case, there is only one component called <code>producer</code>.</li> <li>The <code>name</code> of the component. This name must be unique between all components of the application.</li> <li>The <code>type</code> of the component. Using <code>edgefarm-applications</code> means that the component is deployed to edge nodes.</li> <li>The <code>image</code> of the component. This is the OCI image that is deployed to the edge nodes.</li> <li>Every Edge Node is located in it's unique nodepool called the same as the node. The <code>nodepoolSelector</code> defines which edge nodes shall run the component.</li> <li>This example uses a label called <code>example=producer</code> to identify the edge nodes that shall run the component. The label is set on the edge node using <code>kubectl label nodepools.apps.openyurt.io &lt;your node&gt; example=producer</code>.</li> <li>The <code>name</code> of the container to run.</li> <li>The <code>cpu</code> resources the container is allowed to consume.</li> <li>The <code>memory</code> the container is allowed to consume.</li> <li><code>traits</code> are additional configuration parameters that can be added to the component. </li> <li>There is one trait of type <code>edgefarm-network</code> added to the component. This trait is used to connect the component to the <code>edgefarm.network</code>.</li> <li>The <code>name</code> of the network to connect to.</li> <li>The <code>subnetwork</code> of the network to connect to.</li> <li>The <code>user</code> of the network to connect with.</li> </ol> <p>The application contains one component called <code>producer</code> that runs our OCI image mentioned before. The component is deployed to all nodes, that the corresponding nodepool has the label <code>example=producer</code>. There are also some limits defined how much CPU resources and memory the container is allowed to consume. If the application shall be enabled to communicate with a network, a trait of type <code>edgefarm-network</code> must be added. In this case, the component is connected to the network <code>example-network</code> and the user <code>publish</code> is allowed to publish data to the network. We can define multiple sub-networks in the network definition. In this case, the component is connected to the sub-network <code>edge-to-cloud</code>. We referenced a <code>edgefarm.network</code>. So let's define it. Without the network resource the application would not be able to start. The following snippet shows the network definition:</p> <pre><code>apiVersion: streams.network.edgefarm.io/v1alpha1 #(1)!\nkind: Network\nmetadata:\n  name: example-network #(2)!\nspec:\n  compositeDeletePolicy: Foreground #(3)!\n  parameters: #(4)!\n    users: #(5)!\n      - name: publish #(6)!\n        limits: #(7)!\n          payload: -1 #(8)!\n          data: -1 #(9)!\n          subscriptions: -1 #(10)!\n        permissions: #(11)!\n          pub: #(12)!\n            allow: #(13)!\n              - \"*.sensor\" #(14)!\n              - \"$JS.API.CONSUMER.&gt;\"\n              - \"$JS.ACK.&gt;\"\n            deny: [] #(15)!\n          sub: #(16)!\n            allow: #(17)!\n              - \"*.sensor\" \n            deny: [] #(18)!\n    subNetworks: #(19)!\n      - name: edge-to-cloud #(20)!\n        limits: #(21)!\n          fileStorage: 1G #(22)!\n          inMemoryStorage: 100M #(23)!\n        nodepoolSelector: #(24)!\n          matchLabels:\n            example: \"producer\" #(25)!\n\n    streams: #(26)!\n      - name: sensor-stream #(27)!\n        type: Standard #(28)!\n        subNetworkRef: edge-to-cloud #(29)!\n        config:\n          subjects: #(30)!\n            - \"sensor\" #(31)!\n          discard: Old #(32)!\n          retention: Limits #(33)!\n          storage: File #(34)!\n          maxConsumers: -1 #(35)!\n          maxMsgSize: -1 #(36)!\n          maxMsgs: -1 #(37)!\n          maxMsgsPerSubject: -1 #(38)!\n          maxBytes: 10000000 #(39)!\n\n      - name: aggregate-stream #(40)!\n        type: Aggregate #(41)!\n        config:\n          discard: Old #(32)!\n          retention: Limits #(43)!\n          storage: File #(44)!\n          maxConsumers: -1 \n          maxMsgSize: -1\n          maxMsgs: -1\n          maxMsgsPerSubject: -1\n          maxBytes: 500000000 #(45)!\n        references: #(46)!\n          - sensor-stream #(47)!\n</code></pre> <ol> <li>Every network is of <code>kind: Network</code> and <code>apiversion: streams.network.edgefarm.io/v1alpha1</code>.</li> <li>Give your network a meaningful name. This name is used to identify the network resource in the cluster.</li> <li>The <code>compositeDeletePolicy</code> defines how the network is deleted. This is mandatory to set to <code>Foreground</code> to prevent the network from being deleted before all components are deleted.</li> <li>The <code>parameters</code> section defines the parameters of the network.</li> <li>The <code>users</code> section defines the users that are allowed to publish or subscribe to the network.</li> <li>The <code>name</code> of the user.</li> <li>Users can be limited in their actions. The <code>limits</code> section defines the limits of the user.</li> <li>The <code>payload</code> limit defines how much data a user is allowed to publish to the network. <code>-1</code> means unlimited.</li> <li>TBD</li> <li>The <code>subscriptions</code> limit defines how many subscriptions a user is allowed to create. <code>-1</code> means unlimited.</li> <li>The <code>permissions</code> section defines the permissions of the user regarding publishing and subscribing.</li> <li>The <code>pub</code> section defines the permissions for publishing.</li> <li><code>allow</code> defines which subjects the user is allowed to publish to.</li> <li><code>*.sensor</code> means that the user is allowed to publish to any subject that ends with <code>.sensor</code>. See (Subjet-Based messaging)[https://docs.nats.io/nats-concepts/subjects] for more information on how subjects work.</li> <li><code>deny</code> defines which subjects the user is not allowed to publish to.</li> <li>The <code>sub</code> section defines the permissions for subscribing.</li> <li><code>allow</code> defines which subjects the user is allowed to subscribe to.</li> <li><code>deny</code> defines which subjects the user is not allowed to subscribe to.</li> <li>The <code>subNetworks</code> section defines the sub-networks that are part of the network. Imagine you have two types of Edge Nodes. One is highly potent while the other has a smaller footprint. The potent one can reserve way more file storage than the smaller one. For both types you can define differnt sub-networks with different characteristics.</li> <li><code>name</code> is of the sub-network. This get referenced in the <code>edgefarm.application</code> manifest.</li> <li></li> </ol> <p>The network section is split up into several sub-sections in the spec.  There are <code>users</code> that are allowed to publish or subscribe to specific subjects. There are <code>subNetworks</code> that specifies which parts of the network shall run on which nodes. In this case, the sub-network <code>edge-to-cloud</code> is deployed to all nodes that have the label <code>example=producer</code> and have some file-storage and memory limits set.  There are <code>streams</code> that basically act as buckets. Each bucket has a configurable size. It is configured how long data is kept in the bucket and how much data can be stored in the bucket. It can be defined what to do if the bucket is full. It can drop old messages or block incoming messages. The streams can be defined where to run. They can be either be located in the cloud (no subNetworkRef) or on a edge node (subNetworkRef is set). </p> <p>In this example there are two stream definitions that basically act like this: <code>sensor-stream</code>: Create a bucket with the given size and characteristics on each edge node that matches the subNetworks selector. Each edge node gets its own, unique instance of the stream located on the device. The bucket is named <code>sensor-stream</code>. The bucket is configured to accept messages with the subject <code>sensor</code>. The size is 10000000 bytes. If the bucket is full, drop old messages.</p> <p><code>aggregate-stream</code>: Create a bucket with the given size and characteristics in the cloud. The bucket is named <code>aggregate-stream</code>. The size is 500000000 bytes. If the bucket is full, drop old messages. The bucket is referenced to the <code>sensor-stream</code> meaning that it aggregates all data from all sensor stream instances.</p> <p>There is also a user called <code>publish</code> that is allowed to publish n specific subjects - also \"*.sensor\". The <code>*</code> acts as a wildcard. This is needed, because the producer prefixes it's messages with its unique name. </p> <p>The suNetwork <code>cloud-to-edge</code> defines that each matching edge node is equipped with a component that is part of that specific edgefarm.network. In the end, there is a pod running on each edge node that connects to the network. </p>"},{"location":"knowledge-base/gettingstarted/example-application/#consumer-explained","title":"Consumer explained","text":"<p>The manifest files are located in <code>./consumer/deploy</code></p> <p>The consumer is deployed to the cloud nodes. The following snippet shows a standard Kubernetes deployment manifest:</p> <pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  labels:\n    app.kubernetes.io/instance: example-consumer\n  name: example-consumer\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app.kubernetes.io/instance: example-consumer\n  strategy:\n    rollingUpdate:\n      maxSurge: 25%\n      maxUnavailable: 25%\n    type: RollingUpdate\n  template:\n    metadata:\n      labels:\n        app.kubernetes.io/instance: example-consumer\n    spec:\n      containers:\n        - env:\n            - name: NATS_SERVER\n              value: nats://nats.nats.svc:4222\n            - name: NATS_EXPORT_SUBJECT\n              value: \"*.sensor\"\n            - name: NATS_STREAM_NAME\n              value: aggregate-stream\n            - name: NATS_CREDS\n              value: /creds/network.creds\n          image: ghcr.io/edgefarm/edgefarm/example-basic-consumer:latest\n          imagePullPolicy: IfNotPresent\n          name: consumer\n          resources:\n            limits:\n              cpu: 500m\n              memory: 256Mi\n            requests:\n              cpu: 250m\n              memory: 128Mi\n          volumeMounts:\n            - mountPath: /creds/network.creds\n              name: creds\n              readOnly: true\n              subPath: creds\n      restartPolicy: Always\n      volumes:\n        - name: creds\n          secret:\n            defaultMode: 420\n            secretName: example-network-publish\n</code></pre> <p>This defines a deployment manifest that runs our OCI images referenced earlier. It uses the network credentials as volumes to create the connection to the network. The consumer is configured to consume all messages with the subject <code>*.sensor</code> from the stream <code>aggregate-stream</code>.</p> <p>To be able to access the <code>consumer</code> application we need a standard Kubernetes service resoure. </p> <pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: example-consumer\nspec:\n  ports:\n    - port: 5006\n      targetPort: 5006\n  selector:\n    app.kubernetes.io/instance: example-consumer\n</code></pre> <p>This service exposes the port 5006 of the consumer application to the cluster.</p>"},{"location":"knowledge-base/gettingstarted/example-application/#in-action","title":"In Action","text":"<p>Deploy both, producer and consumer, to the cluster:</p> <pre><code>$ kubectl apply -f ./producer/deploy\napplication.core.oam.dev/example-producer created\nnetwork.streams.network.edgefarm.io/example-network created\n$ kubectl apply -f ./consumer/deploy\ndeployment.apps/example-consumer created\nservice/example-consumer created\n</code></pre> <p>Decide what edge nodes shall run the producer component:</p> <pre><code>$ kubectl label nodepools.apps.openyurt.io edgefarm-worker3 example=producer\nnodepool.apps.openyurt.io/edgefarm-worker3 labeled\n</code></pre> <p>Wait until everything is up and running:</p> <pre><code>$ kubectl get pods     \nNAME                                                              READY   STATUS    RESTARTS   AGE   IP            NODE               NOMINATED NODE   READINESS GATES\nexample-consumer-d69db86c8-n25vb                                  1/1     Running   0          10m   10.244.3.35   edgefarm-worker    &lt;none&gt;           &lt;none&gt;\nexample-network-default-edge-to-cloud-edgefarm-worker3-5fqfsxl5   1/1     Running   0          12m   10.244.1.5    edgefarm-worker3   &lt;none&gt;           &lt;none&gt;\nproducer-edgefarm-worker3-s9pbw-5d6f874f65-qfqmf                  2/2     Running   0          16m   10.244.1.6    edgefarm-worker3   &lt;none&gt;           &lt;none&gt;\n</code></pre> <p>Check the streams that are created and watch the messages flowing in:</p> <pre><code>$ kubectl get streams.nats.crossplane.io -o wide                       \nNAME                          EXTERNAL-NAME      READY   SYNCED   DOMAIN                                                   AGE   ADDRESS                     ACCOUNT PUB KEY                                            MESSAGES   BYTES    CONSUMERS\nexample-network-25gn7-6bhcs   aggregate-stream   True    True     main                                                     10m   nats://nats.nats.svc:4222   ACDB55OTMWZM6LP4R3I3E5WRLJWWVHCWEBLN5ECYOQCN3BTH5NPDMLD4   321        2.0 MB   1\nexample-network-25gn7-qxc2v   sensor-stream      True    True     example-network-default-edge-to-cloud-edgefarm-worker3   10m   nats://nats.nats.svc:4222   ACDB55OTMWZM6LP4R3I3E5WRLJWWVHCWEBLN5ECYOQCN3BTH5NPDMLD4   321        1.9 MB   0\n</code></pre> <p>Forward the service of the <code>consumer</code> to your local machine and open a browser at http://localhost:5006/serve.</p> <pre><code>$ kubectl port-forward service/example-consumer 5006:5006\n</code></pre>"},{"location":"knowledge-base/gettingstarted/portal/","title":"edgefarm.portal","text":"<p>You can find the EdgeFarm Portal here: https://go.edgefarm.io</p>"},{"location":"knowledge-base/gettingstarted/portal/#the-portal-simply-explained","title":"The portal simply explained","text":"<p>The Portal is designed to make it as easy as possible to create new EdgeFarm components and to give an overview of the cluster. In the portal you will find workflows to create new components as well as information and metrics about existing components. Creating components, no matter which component, results in a code change in your upstream Git Repository - remember GitOps, right?</p>"},{"location":"knowledge-base/gettingstarted/portal/#how-to-start","title":"How to start?","text":"<p>Quick overview:</p> <ol> <li>Create a system</li> <li>Add edge node(s)</li> <li>Create network(s)</li> <li>Create application(s)</li> </ol>"},{"location":"knowledge-base/gettingstarted/portal/#1-system","title":"1. System","text":"<p>First, you start by creating a <code>system</code> in the portal. The <code>system</code> is a kind of project or workspace that is specifically linked to a Git repository where your manifest files will be stored.</p> <p>To do this, navigate to https://go.edgefarm.io/create and select the workflow to create a new <code>system</code>.</p> <p>A wizard will ask you for some information. Fill it out and click on 'Create'. After completing this wizard, a new Git repository is created, whose link you can find in the summary of the wizard. Also, an entry has been created in the portal to represent your <code>system</code>.</p>"},{"location":"knowledge-base/gettingstarted/portal/#2-edge-nodes","title":"2. Edge Nodes","text":"<p>Next, you have to make the <code>edge nodes</code> known to the <code>system</code>. There is also a predefined workflow for this. Navigate to https://go.edgefarm.io/create and select the workflow which creates a new node.</p> <p>As before follow the wizard to the end. This workflow has now opened a pull request in your Git repository, which was previously created byt the <code>system</code> component. Click on the link in the wizard summary or navigate to your pull request from the Git interface to merge it. After the merge of the pull request the node can be viewed in the portal.</p> <p>Note: After the merge it may take a few minutes until the node is visible in the portal.</p> <p>To display all <code>edge nodes</code> known to the portal, navigate to the menu item 'Nodes' in the page navigation.</p>"},{"location":"knowledge-base/gettingstarted/portal/#3-networks","title":"3. Networks","text":"<p>As mentioned before, a <code>network</code> is used to let <code>applications</code> communicate. Define which <code>edge node</code> shall be part of the <code>network</code> and define the <code>streams</code> and <code>users</code> that belong to that network. <code>users</code> have specific user defined rights to interact with <code>streams</code>. <code>streams</code> are used to either buffer your data e.g. during poor network connections or aggregate other <code>streams</code> to collect the data of many <code>streams</code>.</p> <p>Note: if your application doesn't need to communicate or send data to other applications, you might want to skip the creation of the <code>network</code>. </p> <p>To create a <code>network</code>, navigate to https://go.edgefarm.io/create and select the workflow that adds a <code>network</code>. Follow the steps of the wizards to the end. Merge the Pull-Request and see your <code>network</code> ocurring in the <code>Networks</code> section in the portal.</p>"},{"location":"knowledge-base/gettingstarted/portal/#4-applications","title":"4. Applications","text":"<p>Define an <code>application</code> by providing a name and a OCI image. You can customize your application spec to your needs by e.g. adding envs, volumes, custom commands and args, ...</p> <p>If your application shall be allowed to communicate with a <code>network</code> define the network specific parts of the application.</p> <p>To create an <code>application</code>, navigate to https://go.edgefarm.io/create and select the workflow that adds a <code>application</code>. Follow the steps of the wizards to the end. Merge the Pull-Request and see your <code>application</code> ocurring in the <code>Applications</code> section in the portal.</p>"},{"location":"knowledge-base/reference/","title":"Overview","text":"<p>This section of the EdgeFarm documentation contains references.</p>"},{"location":"knowledge-base/reference/#api-reference","title":"API Reference","text":"<ul> <li>Glossary - a comprehensive, standardized list of EdgeFarm terminology</li> <li>EdgeFarm API Reference</li> <li>Well-Known Labels, Annotations and Taints</li> </ul>"},{"location":"knowledge-base/reference/reference/api/","title":"API Overview","text":"<p>This section provides reference information for the EdgeFarm API.</p>"},{"location":"knowledge-base/reference/reference/api/#api-reference","title":"API Reference","text":"<ul> <li>edgefarm.applications specs can be found here.</li> <li>edgefarm.network specs can be found here.</li> </ul>"},{"location":"knowledge-base/reference/reference/glossary/","title":"Glossary","text":"<p>This glossary is intended to be a comprehensive, standardized list of EdgeFarm. It includes technical terms that are specific to EdgeFarm and Kubernetes, as well as more general terms that provide useful context. Please take a look at The Kubernetes Glossary as EdgeFarm is based on Kubernetes.</p> <p>Container - a container is a standard unit of software that packages up code and all its dependencies so the application runs quickly and reliably from one computing environment to another. (1)</p> <ol> <li>A container represents a container in general. A container is a standard unit of software that packages up code and all its dependencies so the application runs quickly and reliably from one computing environment to another. A container is a standard unit of software that packages up code and all its dependencies so the application runs quickly and reliably from one computing environment to another. A Docker container image is a lightweight, standalone, executable package of software that includes everything needed to run an application: code, runtime, system tools, system libraries and settings. Container images become containers at runtime and in the case of Docker containers - images become containers when they run on Docker Engine. Available for both Linux and Windows based apps, containerized software will always run the same, regardless of the infrastructure. Containers isolate software from its environment and ensure that it works uniformly despite differences for instance between development and staging.</li> </ol> <p>Edge computing processes data closer to its source, improving real-time performance compared to centralized cloud systems.  (1)</p> <ol> <li>Cloud and Edge refere to an IT environment that abstracts IT resources in a network, combines them into pools and distributes them. An edge is a computing location at the edge of a network. The associated hardware and software is located at these physical locations. Cloud computing involves the execution of workloads in clouds. Edge computing is the execution of workloads on edge devices.</li> </ol> <p>Edge Node - a node with special edge case requirements that is located at the edge. (1)</p> <ol> <li>A node represents a Kubernetes node in general. An Edge Node is a remote device located somewhere completely different e.g. Raspberry Pi connected to the Kubernetes cluster running your workload. Edge Nodes are managed by <code>edgefarm.core</code>. Edge Nodes have advanced features enabled aht are needed to run your workload on the Edge in a reliable way. Edge nodes can be accessed via SSH. Edge autonomy is enabled.</li> </ol> <p>Edge autonomy - edge nodes can operate fully autonomously, even when the connection to the cloud is lost</p> <p>edgefarm.core - core component of EdgeFarm (1)</p> <ol> <li><code>edgefarm.core</code> is responsible for node related things like enabling Edge Nodes, node registration and node autonomy.</li> </ol> <p>edgefarm.applications - workload definition for EdgeFarm (1)</p> <ol> <li><code>edgefarm.applications</code> is responsible for workload related things like rolling out your workload to your Edge Nodes. It is an abstraction layer on top of Kubernetes workload definitions. It allows you to define your workload in a very minimalist format that can be extended to your needs. Using <code>edgefarm.applications</code> you can roll out your custom OCI images and configure advanced settings like volumes, envs, commands, args. You decide which Edge Nodes shall run your workload by using labels.</li> </ol> <p>edgefarm.network - communication between workload running on Edge Nodes and/or in the cloud (1)</p> <ol> <li><code>edgefarm.network</code> is responsible for communication between your workloads running on Edge Nodes and/or in the cloud. It allows you to define streams that act as buffer for your data. Each Edge Device that is part of a Network runs such a stream. Streams can also be used in the cloud aggregating the streams of the Edge Nodes. These streams act as buffers even when the device is offline and needs to operate fully autonomously. Create a Network and let your applications communicate no matter if running in Cloud, Edge or even exported to a third party system. <code>edgefarm.network</code> uses NATS as a message broker. NATS is a lightweight, high-performance cloud native messaging system. It is part of the CNCF.</li> </ol> <p>edgefarm.monitor - monitoring of EdgeFarm related components like Edge Nodes, workloads, networks (1)</p> <ol> <li><code>edgefarm.monitor</code> is responsible for monitoring of EdgeFarm related components like Edge Nodes, workloads, networks. It is based on Grafana Mimir and Grafana. </li> </ol> <p>edgefarm.portal - web interface for EdgeFarm (1)</p> <ol> <li>Based on Spotifys Backstage edgefarm.Portal is the web interface for EdgeFarm. It allows you to manage your EdgeFarm installation. It is the central place to manage your Edge Nodes, your workloads and your networks. </li> </ol>"},{"location":"knowledge-base/reference/reference/api/applications/","title":"edgefarm.applications API Reference","text":""},{"location":"knowledge-base/reference/reference/api/monitor/","title":"edgefarm.monitor API Reference","text":""},{"location":"knowledge-base/reference/reference/api/network/","title":"edgefarm.network specification","text":""},{"location":"knowledge-base/reference/reference/api/applications/application-spec/","title":"API Reference","text":""},{"location":"knowledge-base/reference/reference/api/applications/application-spec/#application","title":"Application","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> <p>An <code>Application</code> is a definition of a set of containers that can run on a Kubernetes Node. This resource is created by clients and scheduled onto hosts.</p> Field Type Description Required apiVersion core.oam.dev/v1beta1 Version of the API true kind Application Type of the resource true metadata object Standard object's metadata true spec object Specification of the desired behavior of the application true"},{"location":"knowledge-base/reference/reference/api/applications/application-spec/#applicationspec","title":"Application.spec","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> Field Type Description Required components []object List of components belonging to the application. Having multiple components in one application means that there are multiple containers managed by the same application. All components are deployed together and share the same lifecycle. true"},{"location":"knowledge-base/reference/reference/api/applications/application-spec/#applicationspeccomponentsindex","title":"Application.spec.components[index]","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> Field Type Description Required name string The name of the component. This name must be unique between all components in an application. true type string The type of the component. This is used to allows the the templating engine behind <code>edgefarm.applications</code> to generate the correct manifest. Currently the supported component is: edgefarm-applications true properties object Properties of the component. This is used to configure the component. The properties are specific to the component type. true"},{"location":"knowledge-base/reference/reference/api/applications/application-spec/#applicationspeccomponentsindexproperties","title":"Application.spec.components[index].properties","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> Field Type Description Required name string The name of the container. true nodePoolSelector object Label selector for nodepools. Every Edge Node has a corresponding nodepool. The nodepool is used to select the Edge Nodes that shall run the component. The nodePoolSelector specifies the nodepools that shall run the component. A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects. true image string OCI container image name. true imagePullPolicy string Image pull policy. One of <code>IfNotPresent</code>, <code>Never</code>, <code>Always</code>. Defaults to <code>IfNotPresent</code> false imagePullSecrets []string Specify image pull secrets. command []string Entrypoint array. Not executed within a shell. The container image's ENTRYPOINT is used if this is not provided. false args []string Arguments to the entrypoint. The container image's CMD is used if this is not provided. false envs []object List of environment variables to set in the container. false tolerations []object The pod this Toleration is attached to tolerates any taint that matches the triple <code>&lt;key,value,effect&gt;</code> using the matching operator. false ports []object List of ports to expose from the container. false cpu string Default values for CPU resources for Requests or Limits is unset. false memory string Default values for Requests and Limits on Memory resources for a container. requests object Resources requested by the container. false limits object Resources allowed for the container. false securityContext object The security context to apply. false traits []object Traits of the component. Traits of the component. This is used to configure the component. The traits are specific to the component type."},{"location":"knowledge-base/reference/reference/api/applications/application-spec/#applicationspeccomponentsindexpropertiessecuritycontext","title":"Application.spec.components[index].properties.securityContext","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> Field Type Description Required allowPrivilegedEscalation bool AllowPrivilegedEscalation determines if a pod can request to allow privilege escalation. If unspecified, defaults to true. false capabilities object The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. false privileged bool Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false. false readOnlyRootFilesystem bool Whether this container has a read-only root filesystem. Default is false. false runAsGroup int64 The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. false runAsNonRoot bool Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. false runAsUser int64 The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. false"},{"location":"knowledge-base/reference/reference/api/applications/application-spec/#applicationspeccomponentsindexpropertiessecuritycontextcapabilities","title":"Application.spec.components[index].properties.securityContext.capabilities","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> Field Type Description Required add []string Added capabilities. false drop []string Removed capabilities. false"},{"location":"knowledge-base/reference/reference/api/applications/application-spec/#applicationspeccomponentsindexpropertiesnodepoolselector","title":"Application.spec.components[index].properties.nodepoolSelector","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> Field Type Description Required matchLabels map[string]string matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed. false matchExpressions []MatchExpression matchExpressions is a list of label selector requirements. The requirements are ANDed. false"},{"location":"knowledge-base/reference/reference/api/applications/application-spec/#applicationspeccomponentsindexpropertiesnodepoolselectorindexmatchexpressionsindex","title":"Application.spec.components[index].properties.nodepoolSelector[index].matchExpressions[index]","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> Field Type Description Required key string The label key that the selector applies to. true operator string Represents a key's relationship to a set of values. Valid operators are <code>In</code>, <code>NotIn</code>, <code>Exists</code>, <code>DoesNotExist</code>. <code>In</code> and <code>NotIn</code> operators can be used with non-empty values. <code>Exists</code> and <code>DoesNotExist</code> operators can be used with empty values. true values []string An array of string values. false"},{"location":"knowledge-base/reference/reference/api/applications/application-spec/#applicationspeccomponentsindexpropertiestolerationsindex","title":"Application.spec.components[index].properties.tolerations[index]","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> Field Type Description Required key string The taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys. operator string Operator represents a key's relationship to the value. Valid operators are <code>Exists</code> and <code>Equal</code>. Defaults to <code>Equal</code>. <code>Exists</code> is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category. value string Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string. effect string Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are <code>NoSchedule</code>, <code>PreferNoSchedule</code> and <code>NoExecute</code>. tolerationSeconds int64 TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system."},{"location":"knowledge-base/reference/reference/api/applications/application-spec/#applicationspeccomponentsindexpropertiesportsindex","title":"Application.spec.components[index].properties.ports[index]","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> Field Type Description Required name string The name of the port mapping. false containerPort int32 Number of port to expose on the pod's IP address. This must be a valid port number, 0 &lt; x &lt; 65536. true hostPort int32 Number of port to expose on the host. If specified, this must be a valid port number, 0 &lt; x &lt; 65536. false protocol string Protocol for port. Must be UDP or TCP. Defaults to \"TCP\". false"},{"location":"knowledge-base/reference/reference/api/applications/application-spec/#applicationspeccomponentsindexpropertiesenvsindex","title":"Application.spec.components[index].properties.envs[index]","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> Field Type Description Required name string Name of the environment variable. true value string The value of the environment variable. false valueFrom object Source for the environment variable's value. Cannot be used if value is not empty. false"},{"location":"knowledge-base/reference/reference/api/applications/application-spec/#applicationspeccomponentsindexpropertiesenvsindexvaluefrom","title":"Application.spec.components[index].properties.envs[index].valueFrom","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> Field Type Description Required configMapKeyRef ConfigMapKeySelector Selects a key of a ConfigMap. false secretKeyRef SecretKeySelector Selects a key of a Secret. false"},{"location":"knowledge-base/reference/reference/api/applications/application-spec/#applicationspeccomponentsindexpropertiesenvsindexvaluefromconfigmapkeyref","title":"Application.spec.components[index].properties.envs[index].valueFrom.configMapKeyRef","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> Field Type Description Required name string The name of the config map in the pod's namespace to select from. true key string The key of the config map to select from. Must be a valid secret key true"},{"location":"knowledge-base/reference/reference/api/applications/application-spec/#applicationspeccomponentsindexpropertiesenvsindexvaluefromsecretkeyref","title":"Application.spec.components[index].properties.envs[index].valueFrom.secretKeyRef","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> Field Type Description Required name string The name of the secret in the pod's namespace to select from. true key string The key of the secret to select from. Must be a valid secret key. true"},{"location":"knowledge-base/reference/reference/api/applications/application-spec/#applicationspeccomponentsindexpropertiesrequests","title":"Application.spec.components[index].properties.requests","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> Field Type Description Required memory string Memory resource requests. Defaults to \"256Mi\". false cpu string CPU resource requests. Defaults to \"250m\". false"},{"location":"knowledge-base/reference/reference/api/applications/application-spec/#applicationspeccomponentsindexpropertiesrequestslimits","title":"Application.spec.components[index].properties.requests.limits","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> Field Type Description Required memory string Memory resource limits. Defaults to \"256Mi\". false cpu string CPU resource limits. Defaults to \"250m\". false"},{"location":"knowledge-base/reference/reference/api/applications/application-spec/#applicationspeccomponentsindexpropertiestraitsindex","title":"Application.spec.components[index].properties.traits[index]","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> <p>Currently supported traits are</p> <ul> <li>edgefarm-network</li> <li>edgefarm-storage</li> </ul> Field Type Description Required name string The name of the trait. true properties map[string]interface{} Properties of the trait. Used to configure the trait. Properties are specific to the trait type. false"},{"location":"knowledge-base/reference/reference/api/applications/examples/","title":"edgefarm.applications Examples","text":"<p>This section contains examples of how to use the edgefarm.applications API.</p>"},{"location":"knowledge-base/reference/reference/api/applications/examples/#application-properties","title":"Application properties","text":"<p>All options are member of Application.spec.components[index].properties.</p>"},{"location":"knowledge-base/reference/reference/api/applications/examples/#scheduling","title":"Scheduling","text":""},{"location":"knowledge-base/reference/reference/api/applications/examples/#nodepoolselector","title":"nodepoolSelector","text":"<p>The nodePoolSelector is a standard Kubernetes LabelSelector.</p> <pre><code>nodePoolSelector:\n  matchLabels:\n    app: \"myapp\"\n  matchExpressions:\n    - key: foo\n      operator: In\n      values:\n        - bar\n</code></pre>"},{"location":"knowledge-base/reference/reference/api/applications/examples/#tolerations","title":"tolerations","text":"<p>Tolerations are default Kubernetes tolerations. Follow the Kubernetes documentation to learn more about tolerations.</p> <pre><code>tolerations:\n  - key: \"key\"\n    operator: \"Equal\"\n    value: \"value\"\n    effect: \"NoSchedule\"\n  - operator: \"Exists\"\n    effect: \"NoExecute\"\n</code></pre>"},{"location":"knowledge-base/reference/reference/api/applications/examples/#image","title":"Image","text":""},{"location":"knowledge-base/reference/reference/api/applications/examples/#image_1","title":"image","text":"<p>Follow the Kubernetes documentation to learn more about image names.</p> <pre><code>image: nginx:latest\n</code></pre>"},{"location":"knowledge-base/reference/reference/api/applications/examples/#imagepullpolicy","title":"imagePullPolicy","text":"<p>Follow the Kubernetes documentation to learn more about imagePullPolicy.</p> <pre><code>imagePullPolicy: Always\n</code></pre>"},{"location":"knowledge-base/reference/reference/api/applications/examples/#imagepullsecrets","title":"imagePullSecrets","text":"<p>Follow the Kubernetes documentation on how to use imagePullSecrets.</p> <pre><code>imagePullSecrets: \n  - name: mysecret\n</code></pre>"},{"location":"knowledge-base/reference/reference/api/applications/examples/#entrypoint","title":"Entrypoint","text":""},{"location":"knowledge-base/reference/reference/api/applications/examples/#command","title":"command","text":"<p>Overrides the container image's ENTRYPOINT. Not executed within a shell. </p> <pre><code>command: \n  - sh\n  - \"-c\"\n  - \"sleep infinity\" \n</code></pre>"},{"location":"knowledge-base/reference/reference/api/applications/examples/#args","title":"args","text":"<p>Arguments to the container image's ENTRYPOINT. The container image's CMD is used if this is not provided. </p> <pre><code>args:\n  - \"-c\"\n  - \"sleep infinity\"\n</code></pre>"},{"location":"knowledge-base/reference/reference/api/applications/examples/#environment-variables","title":"Environment variables","text":"<p>Define environment variables for the container by value or referencing a ConfigMap or a Secret.</p> <pre><code>envs:\n  - name: MY_ENV\n    value: \"my value\"\n  - name: MY_ENV_FROM_SECRET\n    valueFrom:\n      secretKeyRef:\n        name: mysecret\n        key: mykey\n  - name: MY_ENV_FROM_CONFIGMAP\n    valueFrom:\n      configMapKeyRef:\n        name: myconfigmap\n        key: mykey\n</code></pre>"},{"location":"knowledge-base/reference/reference/api/applications/examples/#security-context","title":"Security context","text":""},{"location":"knowledge-base/reference/reference/api/applications/examples/#securitycontext","title":"securityContext","text":"<p>The securityContext is a subset of the Kubernetes SecurityContext.</p> <pre><code>securityContext:\n  allowPrivilegedEscalation: false\n  capabilities:\n    add:\n      - \"NET_ADMIN\"\n    drop:\n      - \"NET_RAW\"\n  privileged: true  \n  readOnlyRootFilesystem: true\n  runAsGroup: 1000\n  runAsNonRoot: true\n  runAsUser: 1000\n</code></pre>"},{"location":"knowledge-base/reference/reference/api/applications/examples/#ports","title":"Ports","text":""},{"location":"knowledge-base/reference/reference/api/applications/examples/#ports_1","title":"ports","text":"<pre><code>ports:\n  - name: http\n    containerPort: 80\n    protocol: TCP\n    hostPort: 8080\n  - containerPort: 9090\n    hostPort: 12345\n</code></pre>"},{"location":"knowledge-base/reference/reference/api/applications/examples/#resources","title":"Resources","text":"<p>The notation for cpu and memory resources is the same as in Kubernetes. Follow the Kubernetes docs for more information.</p>"},{"location":"knowledge-base/reference/reference/api/applications/examples/#cpu","title":"cpu","text":"<p>Used for requests.cpu and limits.cpu if bot are not specified.</p> <pre><code>cpu: 100m\n</code></pre>"},{"location":"knowledge-base/reference/reference/api/applications/examples/#memory","title":"memory","text":"<p>Used for requests.memory and limits.memory if bot are not specified.</p> <pre><code>memory: 100Mi\n</code></pre>"},{"location":"knowledge-base/reference/reference/api/applications/examples/#requests","title":"requests","text":"<pre><code>requests:\n  cpu: 100m\n  memory: 100Mi\n</code></pre>"},{"location":"knowledge-base/reference/reference/api/applications/examples/#limits","title":"limits","text":"<pre><code>limits:\n  cpu: 100m\n  memory: 100Mi\n</code></pre>"},{"location":"knowledge-base/reference/reference/api/applications/examples/#traits","title":"Traits","text":""},{"location":"knowledge-base/reference/reference/api/applications/examples/#edgefarm-network","title":"edgefarm-network","text":"<p>By adding the <code>edgefarm-network</code> trait, you can connect your application to a <code>edgefarm.network</code>.</p> <pre><code>traits:\n  - type: edgefarm-network\n    properties:\n      network:\n        name: mynetwork\n        subnetwork: big\n        user: myuser\n</code></pre>"},{"location":"knowledge-base/reference/reference/api/applications/examples/#edgefarm-storage","title":"edgefarm-storage","text":"<p>You can define multiple storages for a component. Supported storages are <code>hostPath</code>, <code>emptyDir</code>, <code>configMap</code> and <code>secret</code>. Define multiple if you need to mount multiple storages.</p> <pre><code>traits:\n  - type: edgefarm-storage\n    properties:\n      hostPath: \n        - name: myhostpath\n          type: DirectoryOrCreate #(1)!\n          mountPath: /in-container/mypath\n          path: /on-host/mypath\n      emptyDir:\n        - name: myemptydir\n          mountPath: /in-container-/emptydir\n      configMap: #(2)!\n        - name: myconfigmap\n          mountPath: /in-container/myconfigmap\n          items:\n            - key: foo\n              path: foo\n      secret: #(3)!\n        - name: mysecret\n          mountPath: /in-container/mysecret\n</code></pre> <ol> <li>If you specify the optional <code>type</code> and the path or file to mount does not match the type, the application will fail to start.</li> <li>Let's mount the item <code>foo</code> from the ConfigMap <code>myconfigmap</code> to <code>/in-container/myconfigmap/foo</code>.</li> <li>Let's mount all items from the Secret <code>mysecret</code> to <code>/in-container/mysecret</code> inside the container.</li> </ol> <p>You can even create ConfigMaps and Secrets with pre-populated data.</p> <pre><code>traits:\n  - type: edgefarm-storage\n    properties:\n      configMap:\n        - name: myconfigmap\n          mountPath: /in-container/myconfigmap\n          mountOnly: false #(1)!\n          data: #(2)!\n            foo: bar\n      secret:\n        - name: myconfigmap\n          mountPath: /in-container/myconfigmap\n          mountOnly: false \n          data: #(3)!\n            base64encoded: YmFyCg== #(4)!\n          stringData: #(5)!\n            foo: bar\n</code></pre> <ol> <li>Let's express that the ConfigMap shall be created by setting <code>mountOnly</code> to <code>false</code></li> <li>Let's pre-populate the ConfigMap with the key <code>foo</code> and the value <code>bar</code>.</li> <li>Secrets's <code>data</code> field is a map of keys and base64 encoded values.</li> <li><code>YmFyCg==</code> is base64 encoded for <code>bar</code>.</li> <li>Secrets's <code>stringData</code> field is a map of keys and values as strings.</li> </ol>"},{"location":"knowledge-base/reference/reference/api/applications/examples/#full-example-appliations","title":"Full example appliations","text":""},{"location":"knowledge-base/reference/reference/api/applications/examples/#basic-stress-test","title":"Basic stress test","text":"<pre><code>apiVersion: core.oam.dev/v1beta1\nkind: Application\nmetadata:\n  name: stress\nspec:\n  components:\n    - name: stress\n      type: edgefarm-applications\n      properties:\n        image: alexeiled/stress-ng\n        nodepoolSelector:\n          matchLabels:\n            app/stress: \"\" #(1)!\n        name: stress\n        command: #(2)!\n          - \"/stress-ng\"\n          - \"--cpu\"\n          - \"4\"\n          - \"--io\"\n          - \"2\"\n          - \"--vm-bytes\"\n          - \"1G\"\n          - \"timeout\"\n          - \"600s\"\n</code></pre> <ol> <li>This label is used to select the nodepool to deploy the application to. All nodepools that have the label <code>app/stress=</code> will be selected. Keep in mind that the values for label selectors can be unset.</li> <li>To run the stress test we'll override the command of the container.</li> </ol>"},{"location":"knowledge-base/reference/reference/api/applications/examples/#application-with-network-and-storage","title":"Application with network and storage","text":"<pre><code>apiVersion: core.oam.dev/v1beta1\nkind: Application\nmetadata:\n  name: myapp\nspec:\n  components:\n    - name: myapp\n      type: edgefarm-applications\n      properties:\n        image: natsio/nats-box:latest\n        nodepoolSelector:\n          matchLabels:\n            mynetwork-big: \"\" #(1)!\n        name: myapp\n        command: #(2)!\n          - sh\n          - \"-c\"\n          - \"sleep infinity\" \n      traits:\n        - type: edgefarm-network #(3)!\n          properties:\n            network: #(4)!\n              name: mynetwork \n              subnetwork: big \n              user: bigonly\n        - type: edgefarm-storage #(5)!\n          properties:\n            configMap: #(6)!\n              - name: mycm\n                data:\n                  foo: bar\n                mountPath: /mypath\n            emptyDir: #(7)!\n              - name: test1 \n                mountPath: /test/mount/emptydir\n</code></pre> <ol> <li>This application will be deployed to all nodes that have the label <code>mynetwork-big=</code>. Keep in mind that the values for label selectors can be unset.</li> <li>Override the command of the container. </li> <li>A trait <code>edgefarm-network</code> is added allowing the application to connect to a network.</li> <li>By configuring the <code>name</code>, <code>subnetwork</code> and <code>user</code> the application will be able to connect to the network. Note, that the network must exist in order to connect to it. In fact, without the network, the application won't be able to start.</li> <li>A trait <code>edgefarm-storage</code> is added allowing the application to mount volumes.</li> <li>We'll set-up a ConfigMap called <code>mycm</code> and mount it to <code>/mypath</code> inside the container. There is also some data pre-populated in the ConfigMap that can be used by the application with the key <code>foo</code> and the value <code>bar</code>.</li> <li>We'll set-up an emptyDir called <code>test1</code> and mount it to <code>/test/mount/emptydir</code> inside the container. The emptyDir will be created on the node where the application is deployed. The emptyDir will be deleted when the application is deleted.</li> </ol>"},{"location":"knowledge-base/reference/reference/api/applications/network-trait-spec/","title":"API Reference","text":"<p>Trait: <code>edgefarm-network</code></p>"},{"location":"knowledge-base/reference/reference/api/applications/network-trait-spec/#edgefarm-network","title":"Edgefarm-Network","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> Field Type Description Required network object The name of the network the component shall be connected to. true daprProtocol string The protocol used to connect to the network. Supported protocols are <code>grpc</code> and <code>http</code>. Defaults to <code>grpc</code>. false daprGrpcPort int32 The port dapr uses for grpc. Defaults to <code>3500</code>. false daprHttpPort int32 The port dapr uses for http. Defaults to <code>3501</code>. false daprAppPort int32 The port the application uses to communicate with dapr. Defaults to <code>50001</code>. false"},{"location":"knowledge-base/reference/reference/api/applications/network-trait-spec/#edgefarm-networknetwork","title":"Edgefarm-Network.network","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> Field Type Description Required name string The name of the network the component shall be connected to. true username string The username used to authenticate to the network. true subnetwork string The subnetwork used to connect to the network. true"},{"location":"knowledge-base/reference/reference/api/applications/overview/","title":"edgefarm.applications Overview","text":"<p>As EdgeFarm uses OpenYurt as a core component <code>edgefarm.applications</code> is a convenience wrapper around standard Kubernets and OpenYurt APIs.</p> <p>It provides a simple way to describe an application and deploy it to the EdgeFarm cluster. The application delivery model behind it is Open Application Model, or OAM for short and KubeVela.</p>"},{"location":"knowledge-base/reference/reference/api/applications/overview/#application","title":"Application","text":"<p>Writing a manifest for <code>edgefarm.applications</code> is easy. Applications are described in <code>components</code> of a given type. So called <code>taints</code> are used to configure/add/remove specific settings to the components. </p>"},{"location":"knowledge-base/reference/reference/api/applications/overview/#components","title":"Components","text":"<p>Currently supported component types are:</p> <ul> <li>edgefarm-applications - a component that allows you to run your custom OCI images on Edge Nodes</li> </ul>"},{"location":"knowledge-base/reference/reference/api/applications/overview/#traits","title":"Traits","text":"<p>Currently supported traits are:</p> <ul> <li>edgefarm-network - a trait that allows you to connect your application to a network</li> <li>edgefarm-storage - a trait that allows you to mount a volume to your application</li> </ul>"},{"location":"knowledge-base/reference/reference/api/applications/overview/#examples","title":"Examples","text":"<p>See the examples page on how to learn more about <code>edgefarm.applications</code> and how to use it.</p>"},{"location":"knowledge-base/reference/reference/api/applications/storage-trait-spec/","title":"API Reference","text":"<p>Trait: <code>edgefarm-storage</code></p>"},{"location":"knowledge-base/reference/reference/api/applications/storage-trait-spec/#edgefarm-storage","title":"Edgefarm-Storage","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> Field Type Description Required hostPath object Declare host path type storage. false emptyDir object Declare empty dir type storage. false configMap object Declare config map type storage. false secret object Declare secret type storage. false"},{"location":"knowledge-base/reference/reference/api/applications/storage-trait-spec/#edgefarm-storageemptydir","title":"Edgefarm-Storage.emptyDir","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> Field Type Description Required name string The name of the empty dir. true mountPath string The path where the empty dir will be mounted in the container. true subPath string The subpath to mount the empty dir. false medium string By default, the medium volumes are stored. Defaults to \"\". false"},{"location":"knowledge-base/reference/reference/api/applications/storage-trait-spec/#edgefarm-storagehostpath","title":"Edgefarm-Storage.hostPath","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> Field Type Description Required name string The name of the host path. true path string The path on the host. true mountPath string The path where the host path will be mounted in the container. true type string The type of the host path. Valid values are <code>Directory</code>, <code>DirectoryOrCreate</code>, <code>File</code>, <code>FileOrCreate</code>, <code>Socket</code>, <code>CharDevice</code>, and <code>BlockDevice</code>. Defaults to <code>Directory</code>. false"},{"location":"knowledge-base/reference/reference/api/applications/storage-trait-spec/#edgefarm-storageconfigmap","title":"Edgefarm-Storage.configMap","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> Field Type Description Required name string The name of the config map. true mountOnly bool If set to true, the config map will only be mounted and not exposed as environment variables. Defaults to false. false mountToEnv object Mount the config map to an environment variable. false mountToEnvs []object Mount the config map to multiple environment variables. false mountPath string The path where the config map will be mounted in the container. false subPath string The subpath to mount the config map. false defaultMode int32 The default mode to use when mounting the config map. Defaults to 420. false readOnly bool If set to true, the config map will be mounted as read-only. Defaults to false. false data map[string]string The data of the config map. false items []object The items of the config map. false"},{"location":"knowledge-base/reference/reference/api/applications/storage-trait-spec/#edgefarm-storageconfigmapitems","title":"Edgefarm-Storage.configMap.items","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> Field Type Description Required key string The key of the item. true path string The path of the item. true mode int32 The mode of the item. Defaults to 511. false"},{"location":"knowledge-base/reference/reference/api/applications/storage-trait-spec/#edgefarm-storageconfigmapmounttoenv","title":"Edgefarm-Storage.configMap.mountToEnv","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> Field Type Description Required envName string The name of the environment variable. true configMapKey string The key of the config map. true"},{"location":"knowledge-base/reference/reference/api/applications/storage-trait-spec/#edgefarm-storageconfigmapmounttoenvsindex","title":"Edgefarm-Storage.configMap.mountToEnvs[index]","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> Field Type Description Required envName string The name of the environment variable. true configMapKey string The key of the config map. true"},{"location":"knowledge-base/reference/reference/api/applications/storage-trait-spec/#edgefarm-storagesecret","title":"Edgefarm-Storage.secret","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> Field Type Description Required name string The name of the secret. true mountOnly bool If set to true, the secret will only be mounted and not exposed as environment variables. Defaults to false. false mountToEnv object Mount the secret to an environment variable. false mountToEnvs []object Mount the secret to multiple environment variables. false mountPath string The path where the secret will be mounted in the container. true subPath string The subpath to mount the secret. false defaultMode int32 The default mode to use when mounting the secret. Defaults to 420. false readOnly bool If set to true, the secret will be mounted as read-only. Defaults to false. false stringData map[string]string The string data of the secret. false data map[string][]byte The data of the secret. false items object The items of the secret. false"},{"location":"knowledge-base/reference/reference/api/applications/storage-trait-spec/#edgefarm-storagesecretitems","title":"Edgefarm-Storage.secret.items","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> Field Type Description Required key []string The key of the item. true path string The path"},{"location":"knowledge-base/reference/reference/api/applications/storage-trait-spec/#edgefarm-storagesecretmounttoenv","title":"Edgefarm-Storage.secret.mountToEnv","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> Field Type Description Required envName string The name of the environment variable. true secretKey string The key of the secret. true"},{"location":"knowledge-base/reference/reference/api/applications/storage-trait-spec/#edgefarm-storagesecretmounttoenvsindex","title":"Edgefarm-Storage.secret.mountToEnvs[index]","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> Field Type Description Required envName string The name of the environment variable. true secretKey string The key of the secret. true"},{"location":"knowledge-base/reference/reference/api/monitor/overview/","title":"edgefarm.applications Overview","text":""},{"location":"knowledge-base/reference/reference/api/network/examples/","title":"edgefarm.network Examples","text":"<p>This section contains examples of how to use the edgefarm.network API.</p>"},{"location":"knowledge-base/reference/reference/api/network/examples/#complex-example","title":"Complex Example","text":"<p>This example explains a complex scenario of how <code>edgefarm.network</code> can be used. The image shows the network architecture. Let's assume there are two applications called <code>app1</code> and <code>app2</code> that are deployed together on the same Edge Nodes and need to communicate with each other to form a final result. <code>app1</code> might generate some sensor data and <code>app2</code> uses these sensor data and filters them e.g. using a geo-located fence. The results generated by <code>app2</code> need to be transported to the cloud where they can be processed further. Further let's assume that there are differnt kinds of Edge Nodes. Some with small disk capacity and some with large disk capacity leading to different data retention capabilities.</p> <p></p> <p>To control the deployment we label our NodePools with <code>app1/network=small</code> and <code>app1/network=big</code> to distinguish between the different types of Edge Nodes.</p>"},{"location":"knowledge-base/reference/reference/api/network/examples/#users","title":"Users","text":"<p>First the needed users are created in <code>Network.spec.parameters.users</code></p> <p>We create three users: <code>app1</code> and <code>app2</code> that can communicate with each other via some specific topics. <code>app1</code> is able to publish some topics that <code>app2</code> can subscribe to. In addition <code>app2</code> is allowed to publish to <code>topic3</code>. So, both apps can work toghether to form a final result published on <code>topic3</code> by <code>app2</code>. The user <code>external-access</code> can only subscribe to <code>topic3</code>.</p> <p>Limits are set to <code>-1</code> which means unlimited.</p> <pre><code>users:\n  - name: \"app1\" #(1)!\n    limits:\n        payload: -1\n        data: -1\n        subscriptions: -1\n    permissions:\n      pub:\n        allow:\n          - \"topic1.&gt;\"\n          - \"a.b.*.c.&gt;\"\n        deny: []\n      sub:\n        allow: []\n        deny: []\n  - name: \"app2\" #(2)!\n    limits:\n        payload: -1\n        data: -1\n        subscriptions: -1\n    permissions:\n      pub:\n        allow:\n          - \"topic3\"\n        deny: []\n      sub:\n        allow:\n          - \"topic1.&gt;\"\n          - \"a.b.*.c.&gt;\"\n        deny: []\n  - name: \"external-access\" #(3)!\n    limits:\n        payload: -1\n        data: -1\n        subscriptions: -1\n    permissions:\n      sub:\n        allow:\n          - \"topic3\"\n        deny: []\n      pub:\n        allow: []\n        deny: []\n    writeToSecret:\n      name: external-access-creds\n</code></pre> <ol> <li><code>app1</code> is only allowed to publish to specific topics <code>app2</code> is allowed to subscribe to.</li> <li><code>app2</code> is allowed to subscribe to <code>app1</code> published topics is allowed to publish to <code>topic3</code>.</li> <li><code>external-access</code> is only allowed to subscribe to a specific topic from <code>app2</code>. The connection credentials are stored in a specific secret that is accessible by the user by reading a Kubernetes secret.</li> </ol>"},{"location":"knowledge-base/reference/reference/api/network/examples/#subnetworks","title":"Subnetworks","text":"<p>Now let's describe the different storage capabilities of the Edge Nodes. The first type is a small embedded Linux device with very limited storage capabilities while the other is a full blown server with lots of storage. However, we want both types of devices to be able to communicate and to utilize their storage capabilities.</p> <p>To achieve this we can create two subnetworks: <code>small</code> and <code>big</code>. The <code>small</code> subnetwork will be used by the small embedded Linux devices while the <code>big</code> subnetwork will be used by the full blown servers. This way stream can be created for different subnetworks and the storage capabilities of the devices can be used. Eventually, each node with the corresponding node pool labeled with \"app1/network=small\" or \"app1/network=big\" will have an instance of this network.</p> <pre><code>subNetworks:\n  - name: small\n    limits:\n      fileStorage: 300M\n      inMemoryStorage: 10M\n    nodepoolSelector:\n      matchLabels:\n        app1/network: small\n  - name: big\n    limits:\n      fileStorage: 10G\n      inMemoryStorage: 1000M\n    nodepoolSelector:\n      matchLabels:\n        app1/network: big\n</code></pre>"},{"location":"knowledge-base/reference/reference/api/network/examples/#streams","title":"Streams","text":"<p>Let's create the streams that are needed for the applications to communicate with each other. Streams can be added in <code>Network.spec.parameters.streams</code>.</p> <p>This example creates one stream for each subnetwork, with barly the same configuration. The difference is the data retention for the stream on the <code>small</code> subnetwork is much shorter than the one on the <code>big</code> subnetwork. Both streams are configured to behave the same way when it comes to collecting subjects. These streams are meant for the user <code>app1</code> to communicate with each other. </p> <pre><code>streams:\n      - name: app-stream-small #(1)!\n        type: Standard\n        subNetworkRef: small\n        config:\n          subjects:\n            - topic1.&gt;\n            - a.b.*.c.&gt;\n          retention: Limits\n          discard: Old\n          maxConsumers: -1\n          maxMsgs: -1\n          storage: File\n          maxBytes: 100000000 # 100MB\n\n      - name: app-stream-big #(2)!\n        type: Standard\n        subNetworkRef: big\n        config:\n          subjects:\n            - topic1.&gt;\n            - a.b.*.c.&gt;\n          retention: Limits\n          discard: Old\n          maxConsumers: -1\n          maxMsgs: -1\n          storage: File\n          maxBytes: 100000000 # 10GB\n\n      - name: results-stream-small #(3)!\n        type: Standard\n        subNetworkRef: small\n        config:\n          subjects:\n            - topic3\n          retention: Limits\n          discard: Old\n          maxConsumers: -1\n          maxMsgs: -1\n          storage: File\n          maxBytes: 200000000 # 200MB\n\n      - name: results-stream-big #(4)!\n        type: Standard\n        subNetworkRef: big\n        config:\n          subjects:\n            - topic3\n          retention: Limits\n          discard: Old\n          maxConsumers: -1\n          maxMsgs: -1\n          storage: File\n          maxBytes: 200000000 # 200MB\n\n      - name: aggregate-stream #(5)!\n        type: Aggregate\n        references:\n          - results-stream-small\n          - results-stream-big\n        config:\n          retention: Limits\n          discard: Old\n          maxConsumers: -1\n          maxMsgs: -1\n          storage: File\n          maxBytes: 200000000 # 20GB\n</code></pre> <ol> <li>The stream for <code>app1</code> on the <code>small</code> subnetwork has only the size of 100 MB due to limited storage capabilities.</li> <li>The stream for <code>app1</code> on the <code>big</code> subnetwork has the size of 10 GB due to large storage capabilities.</li> <li>The stream for <code>app2</code> on the <code>small</code> subnetwork has only the size of 200 MB. This should be enough to store our final results.</li> <li>The stream for <code>app2</code> on the <code>big</code> subnetwork is configured the same way as the one on the <code>small</code> subnetwork.</li> <li>The aggregate stream is used to aggregate the results from <code>app2</code> on the <code>small</code> and <code>big</code> subnetwork. This stream is configured to have the size of 20 GB.</li> </ol>"},{"location":"knowledge-base/reference/reference/api/network/examples/#final-network-manifest","title":"Final network manifest","text":"<p>Let's put the pieces together. See the final network manifest below.</p> <pre><code>apiVersion: streams.network.edgefarm.io/v1alpha1\nkind: Network\nmetadata:\n  name: mynetwork\n  namespace: mynamespace\nspec:\n  parameters:\n    users:\n      - name: \"app1\"\n        limits:\n            payload: -1\n            data: -1\n            subscriptions: -1\n        permissions:\n          pub:\n            allow:\n              - \"topic1.&gt;\"\n              - \"a.b.*.c.&gt;\"\n            deny: []\n          sub:\n            allow: []\n            deny: []\n      - name: \"app2\"\n        limits:\n            payload: -1\n            data: -1\n            subscriptions: -1\n        permissions:\n          pub:\n            allow:\n              - \"topic3\"\n            deny: []\n          sub:\n            allow:\n              - \"topic1.&gt;\"\n              - \"a.b.*.c.&gt;\"\n            deny: []\n      - name: \"external-access\"\n        limits:\n            payload: -1\n            data: -1\n            subscriptions: -1\n        permissions:\n          sub:\n            allow:\n              - \"topic3\"\n            deny: []\n          pub:\n            allow: []\n            deny: []\n        writeToSecret:\n          name: external-access-creds\n\n    subNetworks:\n      - name: small\n        limits:\n          fileStorage: 100M\n          inMemoryStorage: 10M\n        nodepoolSelector:\n          matchLabels:\n            app1/network: small\n      - name: big\n        limits:\n          fileStorage: 1G\n          inMemoryStorage: 10M\n        nodepoolSelector:\n          matchLabels:\n            app1/network: big\n\n    streams:\n      - name: app-stream-small #(1)!\n        type: Standard\n        subNetworkRef: small\n        config:\n          subjects:\n            - topic1.&gt;\n            - a.b.*.c.&gt;\n          retention: Limits\n          discard: Old\n          maxConsumers: -1\n          maxMsgs: -1\n          storage: File\n          maxBytes: 100000000 # 100MB\n\n      - name: app-stream-big #(2)!\n        type: Standard\n        subNetworkRef: big\n        config:\n          subjects:\n            - topic1.&gt;\n            - a.b.*.c.&gt;\n          retention: Limits\n          discard: Old\n          maxConsumers: -1\n          maxMsgs: -1\n          storage: File\n          maxBytes: 10000000000 # 10GB\n\n      - name: results-stream-small #(3)!\n        type: Standard\n        subNetworkRef: small\n        config:\n          subjects:\n            - topic3\n          retention: Limits\n          discard: Old\n          maxConsumers: -1\n          maxMsgs: -1\n          storage: File\n          maxBytes: 2000000 # 200MB\n\n      - name: results-stream-big #(4)!\n        type: Standard\n        subNetworkRef: big\n        config:\n          subjects:\n            - topic3\n          retention: Limits\n          discard: Old\n          maxConsumers: -1\n          maxMsgs: -1\n          storage: File\n          maxBytes: 2000000 # 200MB\n\n      - name: aggregate-stream #(5)!\n        type: Aggregate\n        references:\n          - results-stream-small\n          - results-stream-big\n        config:\n          retention: Limits\n          discard: Old\n          maxConsumers: -1\n          maxMsgs: -1\n          storage: File\n          maxBytes: 20000000000 # 20GB\n</code></pre>"},{"location":"knowledge-base/reference/reference/api/network/examples/#connect-the-applications-to-the-network","title":"Connect the applications to the network","text":"<p>Now that the network is created, the applications can be connected to the network. This is done by defining an <code>edgefarm.applications</code> definition and using the special <code>edgefarm-network</code> trait.</p> <p>This is an example how the manifests look like for <code>app1</code> and <code>app2</code>.</p> <pre><code>apiVersion: core.oam.dev/v1beta1\nkind: Application\nmetadata:\n  name: app1\n  namespace: mynamespace\nspec:\n  components: #(1)!\n    - name: app1-small\n      type: edgefarm-applications\n      properties:\n        name: app1\n        image: docker.io/myapp/app1:1.0.0\n        nodepoolSelector:\n          matchLabels:\n            app1/network: small\n      traits:\n        - type: edgefarm-network\n          properties:\n            network:\n              name: mynetwork \n              subnetwork: small #(2)!\n              user: app1\n    - name: app1-big\n      type: edgefarm-applications\n      properties:\n        name: app1\n        image: docker.io/myapp/app1:1.0.0\n        nodepoolSelector:\n          matchLabels:\n            app1/network: big\n      traits:\n        - type: edgefarm-network\n          properties:\n            network:\n              name: mynetwork \n              subnetwork: big #(3)!\n              user: app1\n</code></pre> <ol> <li>We define two components representing <code>app1</code> in different subnetworks. Both components connect to the same network using the same user credentials but on different subnetworks. This way, both components running on different types of Edge Nodes can behave the same. </li> <li>The <code>app1-small</code> component connects to the <code>small</code> subnetwork.</li> <li>The <code>app1-big</code> component connects to the <code>big</code> subnetwork.</li> </ol> <p>The Application manifest for <code>app2</code> looks pretty similar to the one for <code>app1</code>.</p> <pre><code>apiVersion: core.oam.dev/v1beta1\nkind: Application\nmetadata:\n  name: app2\n  namespace: mynamespace\nspec:\n  components:\n    - name: app2-small\n      type: edgefarm-applications\n      properties:\n        name: app2\n        image: docker.io/myapp/app2:1.0.0\n        nodepoolSelector:\n          matchLabels:\n            app1/network: small\n      traits:\n        - type: edgefarm-network\n          properties:\n            network:\n              name: mynetwork \n              subnetwork: small\n              user: app2\n    - name: app2-big\n      type: edgefarm-applications\n      properties:\n        name: app2\n        image: docker.io/myapp/app2:1.0.0\n        nodepoolSelector:\n          matchLabels:\n            app1/network: big\n      traits:\n        - type: edgefarm-network\n          properties:\n            network:\n              name: mynetwork \n              subnetwork: big\n              user: app2\n</code></pre>"},{"location":"knowledge-base/reference/reference/api/network/examples/#connect-external-applications-to-the-network","title":"Connect external applications to the network","text":"<p>To connect external applications to the network, the user <code>external-access</code> can be used. The credentials for this user are stored in a Kubernetes secret. To read the <code>creds file</code> for this user, use the following command:</p> <pre><code>$ kubectl get secrets -n mynamespace external-access-creds -o jsonpath='{.data.creds}' | base64 -d\n-----BEGIN NATS USER JWT-----\neyJ0eXAiOiJKV1QiLCJhbGciOiJlZDI1NTE5LW5rZXkifQ.eyJqdGkiOiJZVFNMWFhaT1hVUkkyQk9NWlc1N0hYUEg3UUozRE5MMklOV1VHSEdaV0xQR0NBUzNKQVBRIiwiaWF0IjoxNzAyNjM4MDY4LCJpc3MiOiJBQzNDSFhCNlJWT1hMR0ZIVEFIWEFFU1BBVkVOR1E2NjRXTk9aSEVGQ0tJUURMVkNJSTczVEVZTiIsInN1YiI6IlVEVkxVUE1TQzJPVExUMktEUU82VjRRSFZTWFZDWkpNNDJJVVY0NzJVQjdXRTRDQk8yUFZXVVhMIiwibmF0cyI6eyJwdWIiOnt9LCJzdWIiOnsiYWxsb3ciOlsidG9waWMzIiwiX0lOQk9YLlx1MDAzZSJdfSwic3VicyI6LTEsImRhdGEiOi0xLCJwYXlsb2FkIjotMSwidHlwZSI6InVzZXIiLCJ2ZXJzaW9uIjoyfX0.tXFgmL1J_uJYqbi2bCi-f9htJSPw8Jiv1n5NCsib8yZ4UwUFIwNuViBu4AlMDDaT4z2c73UH_M-o-b03Uu0CBw\n------END NATS USER JWT------\n\n************************* IMPORTANT *************************\nNKEY Seed printed below can be used to sign and prove identity.\nNKEYs are sensitive and should be treated as secrets.\n\n-----BEGIN USER NKEY SEED-----\nSUANAEIEIUD5ZOOE2P63QQKKOOC3A32JVY4X2IEV2S5AXATXVY7LDHSCWM\n------END USER NKEY SEED------\n\n*************************************************************\n</code></pre> <p>As <code>edgefarm.network</code> uses NATS.io as the underlying messaging system, the credentials are in the form of a JWT token and a NKEY seed. The JWT token is used to authenticate the user while the NKEY seed is used to prove idendity. </p> <pre><code>nats --server &lt;the NATS server address&gt; --creds &lt;your creds file&gt; &lt;command&gt;\n</code></pre>"},{"location":"knowledge-base/reference/reference/api/network/overview/","title":"edgefarm.network Overview","text":"<p><code>edgefarm.network</code> uses NATS.io as the technology behind the scenes. It provides a simple way of describing a communication network scheme and deploying it. We take care of security, scalability and reliability. To make <code>edgefarm.network</code> possible, we utilize several Open Source projects:</p> <ul> <li>Hashicorp Vault with our custom natssecrets plugin to manage NATS.io credentials</li> <li>NATS.io as the messaging system</li> <li>Crossplane for providing our custom networking resources</li> <li>OpenYurt for providing the workload resources needed for Edge Nodes</li> <li>Metacontroller for writing custom Kubernets controllers we need</li> </ul>"},{"location":"knowledge-base/reference/reference/api/network/overview/#network","title":"Network","text":"<p>Writing a manifest for <code>edgefarm.network</code> is easy. Networks consist of <code>users</code>, <code>subNetworks</code>, <code>streams</code> and <code>consumers</code>. All is defined in one manifest file. Using the network in a Application is done by using the edgefarm-network trait.</p> <p>See the network-spec page for more details.</p>"},{"location":"knowledge-base/reference/reference/api/network/overview/#examples","title":"Examples","text":"<p>See the examples page on how to learn more about <code>edgefarm.network</code> and how to use it.</p>"},{"location":"knowledge-base/reference/reference/api/network/spec/","title":"API Reference","text":"<p>Packages:</p> <ul> <li>streams.network.edgefarm.io/v1alpha1</li> </ul>"},{"location":"knowledge-base/reference/reference/api/network/spec/#streamsnetworkedgefarmiov1alpha1","title":"streams.network.edgefarm.io/v1alpha1","text":"<p>Resource Types:</p> <ul> <li>Network</li> </ul>"},{"location":"knowledge-base/reference/reference/api/network/spec/#network","title":"Network","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> Name Type Description Required apiVersion string streams.network.edgefarm.io/v1alpha1 true kind string Network true metadata object Refer to the Kubernetes API documentation for the fields of the `metadata` field. true spec object true status object false"},{"location":"knowledge-base/reference/reference/api/network/spec/#networkspec","title":"Network.spec","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> Name Type Description Required parameters object true compositeDeletePolicy enum Enum: Background, Foreground false compositionRef object false compositionRevisionRef object false compositionRevisionSelector object false compositionSelector object false compositionUpdatePolicy enum Enum: Automatic, Manual false publishConnectionDetailsTo object false resourceRef object false writeConnectionSecretToRef object false"},{"location":"knowledge-base/reference/reference/api/network/spec/#networkspecparameters","title":"Network.spec.parameters","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> Name Type Description Required consumers []object            List of consumers false nats object            NATS config false resourceConfig object            Defines general properties for this resource. false streams []object            List of streams false subNetworks []object            The subnetworks that are part of this network  false users []object            List of users to create false"},{"location":"knowledge-base/reference/reference/api/network/spec/#networkspecparametersconsumersindex","title":"Network.spec.parameters.consumers[index]","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> <p>Configuration for a consumer</p> Name Type Description Required config object            Config is the consumer configuration. false name string            The name of the consumer false streamRef string            The name of the stream the consumer is created for Default: main false"},{"location":"knowledge-base/reference/reference/api/network/spec/#networkspecparametersconsumersindexconfig","title":"Network.spec.parameters.consumers[index].config","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> <p>Config is the consumer configuration.</p> Name Type Description Required ackPolicy enum            AckPolicy describes the requirement of client acknowledgements, either Explicit, None, or All. For more information see https://docs.nats.io/nats-concepts/jetstream/consumers#ackpolicy Enum: Explicit, None, All Default: Explicit true ackWait string            AckWait is the duration that the server will wait for an ack for any individual message once it has been delivered to a consumer. If an ack is not received in time, the message will be redelivered. Format is a string duration, e.g. 1h, 1m, 1s, 1h30m or 2h3m4s. Default: 30s true deliverPolicy enum            DeliverPolicy defines the point in the stream to receive messages from, either All, Last, New, ByStartSequence, ByStartTime, or LastPerSubject. Fore more information see https://docs.nats.io/jetstream/concepts/consumers#deliverpolicy Enum: All, Last, New, ByStartSequence, ByStartTime, LastPerSubject Default: All true numReplicas integer            Replicas sets the number of replicas for the consumer's state. By default, when the value is set to zero, consumers inherit the number of replicas from the stream. Default: 0 true replayPolicy enum            ReplayPolicy is used to define the mode of message replay. If the policy is Instant, the messages will be pushed to the client as fast as possible while adhering to the Ack Policy, Max Ack Pending and the client's ability to consume those messages. If the policy is Original, the messages in the stream will be pushed to the client at the same rate that they were originally received, simulating the original timing of messages. Enum: Instant, Original Default: Instant true backoff string            Backoff is a list of time durations that represent the time to delay based on delivery count. Format of the durations is a string duration, e.g. 1h, 1m, 1s, 1h30m or 2h3m4s where multiple durations are separated by commas. Example: `1s,2s,3s,4s,5s`. false description string            Description is a human readable description of the consumer. This can be particularly useful for ephemeral consumers to indicate their purpose since the durable name cannot be provided. false filterSubject string            FilterSubject defines an overlapping subject with the subjects bound to the stream which will filter the set of messages received by the consumer. false inactiveThreshold string            InactiveThreshold defines the duration that instructs the server to cleanup consumers that are inactive for that long. Format is a string duration, e.g. 1h, 1m, 1s, 1h30m or 2h3m4s. false maxAckPending integer            MaxAckPending sets the number of outstanding acks that are allowed before message delivery is halted. Default: 1000 false maxDeliver integer            MaxDeliver is the maximum number of times a specific message delivery will be attempted. Applies to any message that is re-sent due to ack policy (i.e. due to a negative ack, or no ack sent by the client). Default: -1 false memStorage boolean            MemoryStorage if set, forces the consumer state to be kept in memory rather than inherit the storage type of the stream (file in this case). false optStartSeq integer            OptStartSeq is an optional start sequence number and is used with the DeliverByStartSequence deliver policy. Format: int64 false optStartTime string            OptStartTime is an optional start time and is used with the DeliverByStartTime deliver policy. The time format is RFC 3339, e.g. 2023-01-09T14:48:32Z false pull object            PullConsumer defines the pull-based consumer configuration. false push object            PushConsumer defines the push-based consumer configuration. false sampleFreq string            SampleFrequency sets the percentage of acknowledgements that should be sampled for observability. false"},{"location":"knowledge-base/reference/reference/api/network/spec/#networkspecparametersconsumersindexconfigpull","title":"Network.spec.parameters.consumers[index].config.pull","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> <p>PullConsumer defines the pull-based consumer configuration.</p> Name Type Description Required maxBatch integer            MaxRequestBatch defines th maximum batch size a single pull request can make. When set with MaxRequestMaxBytes, the batch size will be constrained by whichever limit is hit first. This is a pull consumer specific setting. false maxBytes integer            MaxRequestMaxBytes defines the  maximum total bytes that can be requested in a given batch. When set with MaxRequestBatch, the batch size will be constrained by whichever limit is hit first. This is a pull consumer specific setting. false maxExpires string            MaxRequestExpires defines the maximum duration a single pull request will wait for messages to be available to pull. This is a pull consumer specific setting. false maxWaiting integer            MaxWaiting defines the maximum number of waiting pull requests. This is a pull consumer specific setting. Default: 512 false"},{"location":"knowledge-base/reference/reference/api/network/spec/#networkspecparametersconsumersindexconfigpush","title":"Network.spec.parameters.consumers[index].config.push","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> <p>PushConsumer defines the push-based consumer configuration.</p> Name Type Description Required deliverGroup string            DeliverGroup defines the queue group name which, if specified, is then used to distribute the messages between the subscribers to the consumer. This is analogous to a queue group in core NATS. See https://docs.nats.io/nats-concepts/core-nats/queue for more information on queue groups. This is a push consumer specific setting. false deliverSubject string            DeliverSubject defines the subject to deliver messages to. Note, setting this field implicitly decides whether the consumer is push or pull-based. With a deliver subject, the server will push messages to client subscribed to this subject. This is a push consumer specific setting. false flowControl boolean            FlowControl enables per-subscription flow control using a sliding-window protocol. This protocol relies on the server and client exchanging messages to regulate when and how many messages are pushed to the client. This one-to-one flow control mechanism works in tandem with the one-to-many flow control imposed by MaxAckPending across all subscriptions bound to a consumer. This is a push consumer specific setting. false headersOnly boolean            HeadersOnly delivers, if set, only the headers of messages in the stream and not the bodies. Additionally adds Nats-Msg-Size header to indicate the size of the removed payload. false idleHeartbeat string            IdleHeartbeat defines, if set, that the server will regularly send a status message to the client (i.e. when the period has elapsed) while there are no new messages to send. This lets the client know that the JetStream service is still up and running, even when there is no activity on the stream. The message status header will have a code of 100. Unlike FlowControl, it will have no reply to address. It may have a description such \"Idle Heartbeat\". Note that this heartbeat mechanism is all handled transparently by supported clients and does not need to be handled by the application. Format is a string duration, e.g. 1h, 1m, 1s, 1h30m or 2h3m4s. This is a push consumer specific setting. false rateLimitBps integer            RateLimit is used to throttle the delivery of messages to the consumer, in bits per second. Format: int64 false"},{"location":"knowledge-base/reference/reference/api/network/spec/#networkspecparametersnats","title":"Network.spec.parameters.nats","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> <p>NATS config</p> Name Type Description Required address string            The address of the NATS server  true operator string            The name of the operator the account is created for true"},{"location":"knowledge-base/reference/reference/api/network/spec/#networkspecparametersresourceconfig","title":"Network.spec.parameters.resourceConfig","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> <p>Defines general properties for this resource.</p> Name Type Description Required accountSecret string            Name of secret containing the account information false kubernetes object            Config for provider kubernetes false natssecrets object            Config for provider natssecrets false userSecret string            Name of secret containing the user information false"},{"location":"knowledge-base/reference/reference/api/network/spec/#networkspecparametersresourceconfigkubernetes","title":"Network.spec.parameters.resourceConfig.kubernetes","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> <p>Config for provider kubernetes</p> Name Type Description Required providerConfigName string            Name of provider config to use for kubernetes false"},{"location":"knowledge-base/reference/reference/api/network/spec/#networkspecparametersresourceconfignatssecrets","title":"Network.spec.parameters.resourceConfig.natssecrets","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> <p>Config for provider natssecrets</p> Name Type Description Required providerConfigName string            Name of provider config to use for natssecrets false"},{"location":"knowledge-base/reference/reference/api/network/spec/#networkspecparametersstreamsindex","title":"Network.spec.parameters.streams[index]","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> <p>Configuration for a stream</p> Name Type Description Required config object            Config is the stream configuration. true name string            The name of the stream false reference string            When type is mirror, the name of the stream to mirror false references []string            When type is aggregate, the names of the streams to aggregate false subNetworkRef string            The name of the sub network the stream is created for Default: main false type enum            The type of the stream Enum: Standard, Aggregate, Mirror Default: Standard false"},{"location":"knowledge-base/reference/reference/api/network/spec/#networkspecparametersstreamsindexconfig","title":"Network.spec.parameters.streams[index].config","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> <p>Config is the stream configuration.</p> Name Type Description Required discard enum            Discard defines the behavior of discarding messages when any streams' limits have been reached. Old (default): This policy will delete the oldest messages in order to maintain the limit. For example, if MaxAge is set to one minute, the server will automatically delete messages older than one minute with this policy. New: This policy will reject new messages from being appended to the stream if it would exceed one of the limits. An extension to this policy is DiscardNewPerSubject which will apply this policy on a per-subject basis within the stream. Enum: Old, New Default: Old true maxBytes integer            MaxBytes defines how many bytes the Stream may contain. Adheres to Discard Policy, removing oldest or refusing new messages if the Stream exceeds this size. Format: int64 Default: -1 true maxConsumers integer            MaxConsumers defines how many Consumers can be defined for a given Stream. Define -1 for unlimited. Default: -1 true maxMsgs integer            MaxMsgs defines how many messages may be in a Stream. Adheres to Discard Policy, removing oldest or refusing new messages if the Stream exceeds this number of messages. Format: int64 Default: -1 true retention enum            Retention defines the retention policy for the stream. Enum: Limits, Interest, WorkQueue Default: Limits true storage enum            Storage defines the storage type for stream data.. Enum: File, Memory Default: File true allowDirect boolean            AllowDirect is a flag that if true and the stream has more than one replica, each replica will respond to direct get requests for individual messages, not only the leader. false allowRollup boolean            AllowRollup is a flag to allow the use of the Nats-Rollup header to replace all contents of a stream, or subject in a stream, with a single new message. false denyDelete boolean            DenyDelete is a flag to restrict the ability to delete messages from a stream via the API. false denyPurge boolean            DenyPurge is a flag to restrict the ability to purge messages from a stream via the API. false description string            Description is a human readable description of the stream. false discardNewPerSubject boolean            DiscardOldPerSubject will discard old messages per subject. Default: false false duplicates string            Duplicates defines the time window within which to track duplicate messages. Default: 2m0s false maxAge string            MaxAge is the maximum age of a message in the stream. Format is a string duration, e.g. 1h, 1m, 1s, 1h30m or 2h3m4s. Default: 0s false maxMsgSize integer            MaxBytesPerSubject defines the largest message that will be accepted by the Stream. Format: int32 Default: -1 Minimum: -1 false maxMsgsPerSubject integer            MaxMsgsPerSubject defines the limits how many messages in the stream to retain per subject. Format: int64 Default: -1 Minimum: -1 false mirror object            Mirror is the mirror configuration for the stream. false mirrorDirect boolean            MirrorDirect is a flag that if true, and the stream is a mirror, the mirror will participate in a serving direct get requests for individual messages from origin stream. false noAck boolean            NoAck is a flag to disable acknowledging messages that are received by the Stream. Default: false false placement object            Placement is the placement policy for the stream. false rePublish object            Allow republish of the message after being sequenced and stored. false replicas integer            Replicas defines how many replicas to keep for each message in a clustered JetStream. Default: 1 Minimum: 1 Maximum: 5 false sealed boolean            Sealed is a flag to prevent message deletion from  the stream  via limits or API. false sources []object            Sources is the list of one or more sources configurations for the stream. false subjects []string            Subjects is a list of subjects to consume, supports wildcards. false template string            Template is the owner of the template associated with this stream. false"},{"location":"knowledge-base/reference/reference/api/network/spec/#networkspecparametersstreamsindexconfigmirror","title":"Network.spec.parameters.streams[index].config.mirror","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> <p>Mirror is the mirror configuration for the stream.</p> Name Type Description Required name string            Name of the origin stream to source messages from. true domain string            Domain is the JetStream domain of where the origin stream exists. This is commonly used between a cluster/supercluster and a leaf node/cluster. false external object            External is the external stream configuration. false filterSubject string            FilterSubject is an optional filter subject which will include only messages that match the subject, typically including a wildcard. false startSeq integer            StartSeq is an optional start sequence the of the origin stream to start mirroring from. Format: int64 false startTime string            StartTime is an optional message start time to start mirroring from. Any messages that are equal to or greater than the start time will be included. The time format is RFC 3339, e.g. 2023-01-09T14:48:32Z false"},{"location":"knowledge-base/reference/reference/api/network/spec/#networkspecparametersstreamsindexconfigmirrorexternal","title":"Network.spec.parameters.streams[index].config.mirror.external","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> <p>External is the external stream configuration.</p> Name Type Description Required apiPrefix string            APIPrefix is the prefix for the API of the external stream. true deliverPrefix string            DeliverPrefix is the prefix for the deliver subject of the external stream. false"},{"location":"knowledge-base/reference/reference/api/network/spec/#networkspecparametersstreamsindexconfigplacement","title":"Network.spec.parameters.streams[index].config.placement","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> <p>Placement is the placement policy for the stream.</p> Name Type Description Required cluster string            Cluster is the name of the Jetstream cluster. true tags []string            Tags defines a list of server tags. false"},{"location":"knowledge-base/reference/reference/api/network/spec/#networkspecparametersstreamsindexconfigrepublish","title":"Network.spec.parameters.streams[index].config.rePublish","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> <p>Allow republish of the message after being sequenced and stored.</p> Name Type Description Required destination string            Destination is the destination subject messages will be re-published to. The source and destination must be a valid subject mapping. For information on subject mapping see https://docs.nats.io/jetstream/concepts/subjects#subject-mapping true source string            Source is an optional subject pattern which is a subset of the subjects bound to the stream. It defaults to all messages in the stream, e.g. &gt;. Default: &gt; true headersOnly boolean            HeadersOnly defines if true, that the message data will not be included in the re-published message, only an additional header Nats-Msg-Size indicating the size of the message in bytes. false"},{"location":"knowledge-base/reference/reference/api/network/spec/#networkspecparametersstreamsindexconfigsourcesindex","title":"Network.spec.parameters.streams[index].config.sources[index]","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> <p>StreamSource dictates how streams can source from other streams.</p> Name Type Description Required name string            Name of the origin stream to source messages from. true domain string            Domain is the JetStream domain of where the origin stream exists. This is commonly used between a cluster/supercluster and a leaf node/cluster. false external object            External is the external stream configuration. false filterSubject string            FilterSubject is an optional filter subject which will include only messages that match the subject, typically including a wildcard. false startSeq integer            StartSeq is an optional start sequence the of the origin stream to start mirroring from. Format: int64 false startTime string            StartTime is an optional message start time to start mirroring from. Any messages that are equal to or greater than the start time will be included. The time format is RFC 3339, e.g. 2023-01-09T14:48:32Z false"},{"location":"knowledge-base/reference/reference/api/network/spec/#networkspecparametersstreamsindexconfigsourcesindexexternal","title":"Network.spec.parameters.streams[index].config.sources[index].external","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> <p>External is the external stream configuration.</p> Name Type Description Required apiPrefix string            APIPrefix is the prefix for the API of the external stream. true deliverPrefix string            DeliverPrefix is the prefix for the deliver subject of the external stream. false"},{"location":"knowledge-base/reference/reference/api/network/spec/#networkspecparameterssubnetworksindex","title":"Network.spec.parameters.subNetworks[index]","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> <p>Configuration for the sub network</p> Name Type Description Required limits object            Hardware limits for the sub network true name string            The name of the sub network true nodepoolSelector object            NodePoolSelector is a label query over nodepool that should match the replica count. It must match the nodepool's labels. false tolerations []object            Indicates the tolerations the pods under this pool have. A pool's tolerations is not allowed to be updated. false"},{"location":"knowledge-base/reference/reference/api/network/spec/#networkspecparameterssubnetworksindexlimits","title":"Network.spec.parameters.subNetworks[index].limits","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> <p>Hardware limits for the sub network</p> Name Type Description Required fileStorage string            How much disk space is available for data that is stored on disk Default: 1G true inMemoryStorage string            How much memory is available for data that is stored in memory Default: 1G true"},{"location":"knowledge-base/reference/reference/api/network/spec/#networkspecparameterssubnetworksindexnodepoolselector","title":"Network.spec.parameters.subNetworks[index].nodepoolSelector","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> <p>NodePoolSelector is a label query over nodepool that should match the replica count. It must match the nodepool's labels.</p> Name Type Description Required matchExpressions []object            matchExpressions is a list of label selector requirements. The requirements are ANDed. false matchLabels map[string]string            matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed. false"},{"location":"knowledge-base/reference/reference/api/network/spec/#networkspecparameterssubnetworksindexnodepoolselectormatchexpressionsindex","title":"Network.spec.parameters.subNetworks[index].nodepoolSelector.matchExpressions[index]","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> <p>A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.</p> Name Type Description Required key string            key is the label key that the selector applies to. true operator string            operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist. true values []string            values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch. false"},{"location":"knowledge-base/reference/reference/api/network/spec/#networkspecparameterssubnetworksindextolerationsindex","title":"Network.spec.parameters.subNetworks[index].tolerations[index]","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> <p>The pod this Toleration is attached to tolerates any taint that matches the triple  using the matching operator . Name Type Description Required effect string            Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute. false key string            Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys. false operator string            Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category. false tolerationSeconds integer            TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system. Format: int64 false value string            Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string. false"},{"location":"knowledge-base/reference/reference/api/network/spec/#networkspecparametersusersindex","title":"Network.spec.parameters.users[index]","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> Name Type Description Required limits object            The limits for the user false name string            The name of the user false permissions object            The pub/sub permissions for the user false writeToSecret object            The secret to write the user credentials to false"},{"location":"knowledge-base/reference/reference/api/network/spec/#networkspecparametersusersindexlimits","title":"Network.spec.parameters.users[index].limits","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> <p>The limits for the user</p> Name Type Description Required data integer            Specifies the maximum number of bytes Format: int64 false payload integer            Specifies the maximum message payload Format: int64 false subscriptions integer            Specifies the maximum number of subscriptions Format: int64 false"},{"location":"knowledge-base/reference/reference/api/network/spec/#networkspecparametersusersindexpermissions","title":"Network.spec.parameters.users[index].permissions","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> <p>The pub/sub permissions for the user</p> Name Type Description Required pub object            Specifies the publish permissions false sub object            Specifies the subscribe permissions false"},{"location":"knowledge-base/reference/reference/api/network/spec/#networkspecparametersusersindexpermissionspub","title":"Network.spec.parameters.users[index].permissions.pub","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> <p>Specifies the publish permissions</p> Name Type Description Required allow []string            Specifies allowed subjects false deny []string            Specifies denied subjects false"},{"location":"knowledge-base/reference/reference/api/network/spec/#networkspecparametersusersindexpermissionssub","title":"Network.spec.parameters.users[index].permissions.sub","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> <p>Specifies the subscribe permissions</p> Name Type Description Required allow []string            Specifies allowed subjects false deny []string            Specifies denied subjects false"},{"location":"knowledge-base/reference/reference/api/network/spec/#networkspecparametersusersindexwritetosecret","title":"Network.spec.parameters.users[index].writeToSecret","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> <p>The secret to write the user credentials to</p> Name Type Description Required name string            The name of the secret true"},{"location":"knowledge-base/reference/reference/api/network/spec/#networkspeccompositionref","title":"Network.spec.compositionRef","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> Name Type Description Required name string true"},{"location":"knowledge-base/reference/reference/api/network/spec/#networkspeccompositionrevisionref","title":"Network.spec.compositionRevisionRef","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> Name Type Description Required name string true"},{"location":"knowledge-base/reference/reference/api/network/spec/#networkspeccompositionrevisionselector","title":"Network.spec.compositionRevisionSelector","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> Name Type Description Required matchLabels map[string]string true"},{"location":"knowledge-base/reference/reference/api/network/spec/#networkspeccompositionselector","title":"Network.spec.compositionSelector","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> Name Type Description Required matchLabels map[string]string true"},{"location":"knowledge-base/reference/reference/api/network/spec/#networkspecpublishconnectiondetailsto","title":"Network.spec.publishConnectionDetailsTo","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> Name Type Description Required name string true configRef object Default: map[name:default] false metadata object false"},{"location":"knowledge-base/reference/reference/api/network/spec/#networkspecpublishconnectiondetailstoconfigref","title":"Network.spec.publishConnectionDetailsTo.configRef","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> Name Type Description Required name string false"},{"location":"knowledge-base/reference/reference/api/network/spec/#networkspecpublishconnectiondetailstometadata","title":"Network.spec.publishConnectionDetailsTo.metadata","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> Name Type Description Required annotations map[string]string false labels map[string]string false type string false"},{"location":"knowledge-base/reference/reference/api/network/spec/#networkspecresourceref","title":"Network.spec.resourceRef","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> Name Type Description Required apiVersion string true kind string true name string true"},{"location":"knowledge-base/reference/reference/api/network/spec/#networkspecwriteconnectionsecrettoref","title":"Network.spec.writeConnectionSecretToRef","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> Name Type Description Required name string true"},{"location":"knowledge-base/reference/reference/api/network/spec/#networkstatus","title":"Network.status","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> Name Type Description Required account string            The UID of the account resource  false conditions []object            Conditions of the resource. false connectionDetails object false operator string            The operator for the NATS server  false sysAccount string            The sys account name for the NATS server  false system string            The UID of the secret user resource  false"},{"location":"knowledge-base/reference/reference/api/network/spec/#networkstatusconditionsindex","title":"Network.status.conditions[index]","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> Name Type Description Required lastTransitionTime string Format: date-time true reason string true status string true type string true message string false"},{"location":"knowledge-base/reference/reference/api/network/spec/#networkstatusconnectiondetails","title":"Network.status.connectionDetails","text":"<p><sup><sup>\u21a9 Parent</sup></sup></p> Name Type Description Required lastPublishedTime string Format: date-time false"},{"location":"knowledge-base/reference/well-known/well-known/","title":"Well-Known Labels, Annotations and Taints","text":""},{"location":"knowledge-base/reference/well-known/well-known/#labels","title":"Labels","text":""},{"location":"knowledge-base/reference/well-known/well-known/#openyurtiois-edge-worker","title":"openyurt.io/is-edge-worker","text":"<p>Type: Label Example: <code>openyurt.io/is-edge-worker=true</code> Used on: nodes</p> <p>If this label is set to true on a node, it will be considered an Edge Node. This will enable special features like node autonomy.</p>"},{"location":"knowledge-base/reference/well-known/well-known/#openyurtionode-pool-type","title":"openyurt.io/node-pool-type","text":"<p>Type: Label Example: <code>openyurt.io/node-pool-type=edge</code> Used on: nodepools</p> <p>If this label is set to <code>edge</code> on a nodepool, it will be considered an Edge Nodepool. The value can also be set to <code>cloud</code> as the nodepool controller also supports cloud nodepools.</p>"},{"location":"knowledge-base/reference/well-known/well-known/#appsopenyurtiodesired-nodepool","title":"apps.openyurt.io/desired-nodepool","text":"<p>Type: Label Example: <code>apps.openyurt.io/desired-nodepool=edge0</code> Used on: nodes</p> <p>If this label is set on a node the nodepool controller will try to move the node to the nodepool specified in the label. This is part of the mapping between nodes and nodepools.</p>"},{"location":"knowledge-base/reference/well-known/well-known/#appsopenyurtionodepool","title":"apps.openyurt.io/nodepool","text":"<p>Type: Label Example: <code>apps.openyurt.io/nodepool=edge0</code> Used on: nodes</p> <p>If this label is set on a node it means that the mapping to the corresponding nodepool is active.</p>"},{"location":"knowledge-base/tutorials/","title":"Tutorials","text":"<p>This section contains tutorials that show you how to use EdgeFarm in practice.</p> <p>See navigation on the left to navigate through the tutorials.</p>"},{"location":"knowledge-base/tutorials/cluster/create-hetzner-cluster/","title":"Create a EdgeFarm cluster that runs on Hetzner Cloud","text":"<p>This tutorial will guide you through the process of creating a EdgeFarm cluster that runs on Hetzner Cloud. This is a good choice if you want to run a EdgeFarm cluster in a more production like environment. You can then follow the Getting Started guide to deploy your first application.</p>"},{"location":"knowledge-base/tutorials/cluster/create-hetzner-cluster/#prerequisites","title":"Prerequisites","text":""},{"location":"knowledge-base/tutorials/cluster/create-hetzner-cluster/#install-kubectl","title":"Install kubectl","text":"LinuxMacOSWindows running WSL2 <p>How to install Docker on Linux</p> <p>Choose the right version of kubectl for your architecture:</p> amd64arm64 <p>kubectl v1.22.17 - click to download</p> <p>kubectl v1.22.17 - click to download</p> <p>How to install Docker on macOS</p> <p>Choose the right version of kubectl for your architecture:</p> amd64arm64 <p>kubectl v1.22.17 - click to download</p> <p>kubectl v1.22.17 - click to download</p> <p>How to install Docker in Windows and WSL2 backend</p> <p>kubectl v1.22.17 - click to download</p>"},{"location":"knowledge-base/tutorials/cluster/create-hetzner-cluster/#prepare-hetzner-cloud","title":"Prepare Hetzner Cloud","text":"<p>Prepare your Hetzner Cloud account by creating a SSH-Key and a API Token. You can do this in the Hetzner Cloud Console. Visit https://console.hetzner.cloud/ and login with your credentials.</p>"},{"location":"knowledge-base/tutorials/cluster/create-hetzner-cluster/#create-a-ssh-key-for-your-hetzner-project","title":"Create a SSH-Key for your Hetzner project","text":"<p>You need to create a SSH-Key for your Hetzner project. Navigate to your project and then to security. Here you are able to create a new SSH-Key. Enter your public Key, give it a name and enable the <code>Set as default key</code> option. Keep the SSH key name for later.</p> <p> </p> <p>Click the images to see the full size.</p>"},{"location":"knowledge-base/tutorials/cluster/create-hetzner-cluster/#create-a-hetzner-api-token","title":"Create a Hetzner API Token","text":"<p>You need to create a read/write API token in your Hetzner project. Keep the API token for later.</p> <p> </p>"},{"location":"knowledge-base/tutorials/cluster/create-hetzner-cluster/#prepare-netbirdio","title":"Prepare netbird.io","text":"<p>You need an account at netbird.io. This step is mandatory and cannot be skipped. Create a free account and create a personal access token. Keep the access token for later.  Follow the netbird docs.</p> <p>Keep the created access token for later. </p> <p>Also, you need to ensure some authentication settings. Disable both <code>Peer approval</code> and <code>Peer login expiration</code> in the <code>Settings</code> section of Netbird.io</p> <p></p>"},{"location":"knowledge-base/tutorials/cluster/create-hetzner-cluster/#create-the-hetzner-cluster","title":"Create the hetzner cluster","text":"<p>In order to create the cluster on Hetzner Cloud, you need to have a local bootstrap cluster running. This is a (temporary) cluster to create and maintain the Hetzner Cloud cluster. The bootstrap cluster is created automatically by the <code>local-up</code> tool and keeps the Hetzner Cluster alive if something goes terribly wrong with any nodes. </p> <p>Download the <code>local-up</code> tool from the EdgeFarm releases page or run this command:</p> <pre><code>curl -sfL https://raw.githubusercontent.com/edgefarm/edgefarm/main/install.sh | sh -s -- -b ~/bin &amp;&amp; chmod +x ~/bin/local-up\n</code></pre> <p>Once you've got everything set up, go ahead and run the local-up tool to generate a configuration file for a Hetzner Cloud type cluster. </p> <pre><code>local-up cluster create --generate-config --type hetzner &gt; ~/my-hetzner-cluster.yaml\n</code></pre> <p>You are faced with a configuration file tempalte. When filled out it might looks like this</p> <pre><code>kind: Cluster\napiVersion: config.edgefarm.io/v1alpha1\nmetadata:\n  name: edgefarm #(1)!\nspec:\n  type: hetzner #(2)!\n  general:  #(3)!\n    kubeConfigPath: ~/.edgefarm-local-up/edgefarm-bootstrap  \n    statePath: ~/.edgefarm-local-up/edgefarm.json\n  hetzner:\n    controlPlane: #(4)!\n      count: 3  \n      machineType: cx21 \n    workers: #(5)!\n      count: 2\n      machineType: cx31\n    hetznerCloudRegion: nbg1 #(6)!\n    hetznerCloudSSHKeyName: mykey #(7)!\n    hcloudToken: kc6Qd16KTRdvUL7eT0j3F2gW2C3trGiFOtS7HbScUQxASly################# #(8)!\n    kubeConfigPath: ~/.edgefarm-local-up/hetzner #(9)!\n  netbird:\n    setupKey: &lt;your netbird.io setup key&gt; #(10)!\n</code></pre> <ol> <li>You might want to change the name of the cluster</li> <li>The type of the cluster is <code>hetzner</code>. This is important, as the local-up tool will use this to determine which cloud provider to use.</li> <li>The <code>spec.general</code> section contains the paths of the kubeconfig for the bootstrap cluster and the path to a state file. Change paths if you like.</li> <li>Within <code>spec.hetzner.controlPlane</code> define the number of control plane nodes and the machine type. See https://docs.hetzner.com/cloud/servers/overview#shared-vcpu for available machine types.</li> <li>Within <code>spec.hetzner.workers</code> define the number of worker nodes and the machine type. See https://docs.hetzner.com/cloud/servers/overview#shared-vcpu for available machine types.</li> <li>The Hetzner Cloud region to use. See https://docs.hetzner.com/cloud/general/locations#what-locations-are-there for available regions/locations.</li> <li>Enter the name of the SSH key you previously created or any other you want to use to access the nodes. You can create a new SSH key in the Hetzner Cloud Console.</li> <li>Enter the name of the Hetzner Cloud API token you previously created.</li> <li>The path to the kubeconfig file for the Hetzner Cloud cluster. Change if you like.</li> <li>Leave the setupKey for now. It will be configured later.</li> </ol> <p>The next step is to preconfigure netbird.io. For this step you need the netbird API token created earlier. </p> <pre><code>local-up vpn preconfigure --netbird-token &lt;your-access-token&gt; --config ~/my-hetzner-cluster.yaml\n</code></pre> <p>This will configure netbird.io with the given access token and create a setup key. The setup key is then added to the configuration file automatically.</p> <p>Now you can create the Hetzner Cloud cluster with the following command:</p> <pre><code>local-up cluster create --config ~/my-hetzner-cluster.yaml\n</code></pre> kubeconfig path notes <p>The location for the kubeconfig file is configured in your cluste config file in <code>.spec.hetzner.kubeConfigPath</code>. This means, you have to set the <code>KUBECONFIG</code> environment variable to access the cluster with <code>kubectl</code>:</p> <p>In the example the path was set to <code>~/.edgefarm-local-up/hetzner</code>. You can set the <code>KUBECONFIG</code> environment variable like this:</p> <pre><code>export KUBECONFIG=~/.edgefarm-local-up/hetzner\n</code></pre> <p>or use the <code>--kubeconfig</code> flag with <code>kubectl</code>:</p> <pre><code>kubectl --kubeconfig ~/.edgefarm-local-up/hetzner get nodes\n</code></pre> <p>or the even better choice: use a tool to manage multiple kube contexts for you, e.g. kubecm or  kubie</p> <p>If everything went well, you should see something like this:</p> <pre><code>The hetzner cluster has been created.\nRun $ local-up deploy --config &lt;hetzner-config.yaml&gt; to deploy EdgeFarm components and its dependencies.\nHave a look at the arguments using '--help'.\n</code></pre>"},{"location":"knowledge-base/tutorials/cluster/create-hetzner-cluster/#deploy-edgefarm-components","title":"Deploy EdgeFarm components","text":"<p>Now you can deploy the EdgeFarm components to the Hetzner Cloud cluster. </p> <pre><code>$ local-up deploy --config ~/my-hetzner-cluster.yaml\n</code></pre> <p>This will deploy the EdgeFarm components and its dependencies to the Hetzner Cloud cluster. This might take a few minutes.</p> <p>If everything went well, you should see something like this:</p> <pre><code>The EdgeFarm cluster is ready to use! Have fun exploring EdgeFarm.\nTo access the cluster use 'kubectl', e.g.\n $ kubectl get nodes\n</code></pre> <p>deploy notes</p> <p>See <code>deploy</code> options using the <code>--help</code> flag to skip certain components or to deploy a specific component only.</p>"},{"location":"knowledge-base/tutorials/cluster/create-hetzner-cluster/#deleting-the-cluster","title":"Deleting the cluster","text":"<p>If you want to delete the cluster, you can do this with the following command:</p> <pre><code>local-up cluster delete --config ~/my-hetzner-cluster.yaml\n</code></pre> <p>This deletes the Hetzner Cloud cluster followed by the bootstrap cluster. Log into https://console.hetzner.cloud/ and verify that all servers and load balancers are deleted. Go to volumes and delete the volumes manually if needed.</p>"},{"location":"knowledge-base/tutorials/cluster/create-hetzner-cluster/#considerations","title":"Considerations","text":""},{"location":"knowledge-base/tutorials/cluster/create-hetzner-cluster/#costs","title":"Costs","text":"<p>Running a Hetzner Cloud cluster will incur costs. The costs depend on the number of nodes, the machine types and the region you choose. You can find the pricing information on the Hetzner Cloud pricing page. To create a HA cluster, you need at least 3 control plane nodes (minimum cx21). For the worker nodes, you can start with 2 nodes (minimum cx31). As of time of writing, the costs for a cluster with 3 control plane nodes and 2 worker nodes in the nbg1 region are around 50\u20ac per month.</p>"},{"location":"knowledge-base/tutorials/cluster/create-hetzner-cluster/#management","title":"Management","text":"<p>It's totaly up to you how to create and manage your kubeadm cluster that runs EdgeFarm. If you use <code>local-up</code> to create the cluster, you get the local running bootstrap cluster. As long as you don't delete the bootstrap cluster, the Hetzner Cloud cluster will be kept alive. If you delete the bootstrap cluster only e.g. by deleting the local container, be aware that the Hetzner Cloud cluster will be still alive. However, it isn't managed anymore. This means if anything goes haywire with any node, it won't be fixed automatically. You have to take care of it manually. Always be aware of the costs you have to pay for the Hetzner Cloud cluster.</p>"},{"location":"knowledge-base/tutorials/cluster/create-local-cluster/","title":"Create a local EdgeFarm cluster for testing","text":"<p>Before you decide wether EdgeFarm is the right solution for you, you might want to try it out. This guide will help you to set up a EdgeFarm cluster for testing that runs on your local machine. In the end you will have a EdgeFarm cluster running in a dockerized environment. You can then follow the Getting Started guide to deploy your first application.</p> <p>Not for production</p> <p>This is not a production-ready setup. It is meant for you trying out EdgeFarm.</p>"},{"location":"knowledge-base/tutorials/cluster/create-local-cluster/#prerequisites","title":"Prerequisites","text":"LinuxMacOSWindows running WSL2 <p>How to install Docker on Linux</p> <p>Choose the right version of kubectl for your architecture:</p> amd64arm64 <p>kubectl v1.22.17 - click to download</p> <p>kubectl v1.22.17 - click to download</p> <p>How to install Docker on macOS</p> <p>Choose the right version of kubectl for your architecture:</p> amd64arm64 <p>kubectl v1.22.17 - click to download</p> <p>kubectl v1.22.17 - click to download</p> <p>How to install Docker in Windows and WSL2 backend</p> <p>kubectl v1.22.17 - click to download</p>"},{"location":"knowledge-base/tutorials/cluster/create-local-cluster/#create-a-local-cluster","title":"Create a local cluster","text":"<p>Download the <code>local-up</code> tool from the EdgeFarm releases page or run this command:</p> <pre><code>curl -sfL https://raw.githubusercontent.com/edgefarm/edgefarm/main/install.sh | sh -s -- -b ~/bin &amp;&amp; chmod +x ~/bin/local-up\n</code></pre> <p>Once you've got everything set up, go ahead and run the local-up tool. This could take a while, so grab a coffee while you wait. </p> <pre><code>local-up cluster create \n</code></pre> <p>Using cluster config file</p> <p>You can use a custom cluster configuration file by providing the <code>--config</code> flag and change the default values. Create a config file by running  <code>local-up cluster create --generate-config --type local</code> and adjust the values to your needs. You need to pass the config file to the <code>local-up</code> command with the <code>--config</code> flag.</p> kubeconfig path notes <p>The default location for the kubeconfig file is <code>~/.edgefarm-local-up/kubeconfig</code>. This is by intention not to interfer with any existing clusters you might have. This means, you have to set the <code>KUBECONFIG</code> environment variable to use the local cluster with <code>kubectl</code>:</p> <pre><code>export KUBECONFIG=~/.edgefarm-local-up/kubeconfig\n</code></pre> <p>or use the <code>--kubeconfig</code> flag with <code>kubectl</code>:</p> <pre><code>kubectl --kubeconfig ~/.edgefarm-local-up/kubeconfig get nodes\n</code></pre> <p>or the even better choice: use a tool to manage multiple kube contexts for you, e.g. kubecm or  kubie</p>"},{"location":"knowledge-base/tutorials/cluster/create-local-cluster/#deploy-edgefarm-components","title":"Deploy EdgeFarm components","text":"<p>Now you can deploy the EdgeFarm components to the local cluster. </p> <pre><code>$ local-up deploy\n</code></pre> <p>This will deploy the EdgeFarm components and its dependencies to the local cluster. This might take a few minutes.</p> <p>If everything went well, you should see something like this:</p> <pre><code>The EdgeFarm cluster is ready to use! Have fun exploring EdgeFarm.\nTo access the cluster use 'kubectl', e.g.\n $ kubectl get nodes\n</code></pre> <p>deploy notes</p> <p>See <code>deploy</code> options using the <code>--help</code> flag to skip certain components or to deploy a specific component only.</p> <p>If everything went well, you should see something like this:</p> <pre><code>The local EdgeFarm cluster is ready to use! Have fun exploring EdgeFarm.\nTo access the cluster use 'kubectl', e.g.\n  $ kubectl get nodes\n</code></pre>"},{"location":"knowledge-base/tutorials/cluster/create-local-cluster/#enable-vpn","title":"Enable VPN","text":"<p>If you want to join physical edge nodes to the cluster, you need to setup a free account at netbird.io and create a personal access token first. Follow the netbird docs.  If you don't want to join physical edge nodes, you can skip this step.</p> <p>If you have a personal access token, you can enable the VPN with the following command:</p> <pre><code>local-up vpn enable --netbird-token &lt;your-access-token&gt;\n</code></pre>"},{"location":"knowledge-base/tutorials/cluster/create-local-cluster/#delete-the-local-cluster","title":"Delete the local cluster","text":"<p>If you want to delete the local cluster, you can run the following command:</p> <pre><code>local-up cluster delete\n</code></pre> <p>This will delete the local cluster and all its components.</p>"},{"location":"knowledge-base/tutorials/cluster/create-local-cluster/#considerations","title":"Considerations","text":""},{"location":"knowledge-base/tutorials/cluster/create-local-cluster/#costs","title":"Costs","text":"<p>Running a local cluster on your machine is totaly free. However, if you want to join physical edge nodes to the cluster, you need to setup a free account at netbird.io.</p>"},{"location":"knowledge-base/tutorials/cluster/join-ubuntu-22-04-edge-node/","title":"Join a physical edge node running vanilla Ubuntu 22.04 to an EdgeFarm cluster","text":"<p>First, select the type of EdgeFarm cluster you have:</p> Local EdgeFarm clusterCloud Cluster (e.g. Hetzner) <p>You need a running and VPN enabled EdgeFarm cluster. See Create a local EdgeFarm cluster for testing for instructions.</p> <p>You need a running and Cloud driven EdgeFarm cluster, e.g. running on Hetzner Cloud. See Create a EdgeFarm cluster that runs on Hetzner Cloud for instructions.</p> <p>Raspberry Pi 4 notes</p> <p>For the Raspberry Pi you need to install the package <code>linux-modules-extra-raspi</code> and enable some boot options to make it work with Kubernetes.</p> <pre><code>apt update\napt install linux-modules-extra-raspi\nsed -i '$s/$/ cgroup_enable=cpuset cgroup_memory=1 cgroup_enable=memory/' /boot/firmware/cmdline.txt\n</code></pre>"},{"location":"knowledge-base/tutorials/cluster/join-ubuntu-22-04-edge-node/#prerequisites","title":"Prerequisites","text":"<p>This How-To shows how to add a Raspberry Pi 4 with a vanilla Ubuntu 22.04 as an Edge Node.  If you have a different hardware or OS your mileage may vary but the general steps should be adaptable.</p> <p>The device should be running</p> <ul> <li>Ubuntu 22.04 LTS</li> <li>systemd</li> <li>Docker</li> <li>udev</li> <li>cgroupv2</li> </ul>"},{"location":"knowledge-base/tutorials/cluster/join-ubuntu-22-04-edge-node/#pre-register-the-edge-node-using-local-up","title":"Pre-register the Edge Node using <code>local-up</code>","text":"<p>Pre-register the node using <code>local-up</code> to create the corresponding resources for the edge node. </p> <p>By default, the nodename is the hostname of the edge node. If you didn't define a different TTL using the <code>--ttl</code> argument for your token, you have 24 hours to join the node to the cluster. After that, the token expires and you won't be able to join using this token.</p> <p>See this example to pre-register a node with the name <code>eagle</code>:</p> Local EdgeFarm clusterCloud Cluster (e.g. Hetzner) <pre><code>$ local-up node join --name eagle\nHere is some information you need to join a edge node to this cluster.\n\nVPN:\nIf you haven't already linked the node to the netbird.io VPN, you must establish the connection to the VPN beforehand.\n\nUse can use this setup-key 375EE66D-E647-4B75-A9FC-########### to connect to netbird.io VPN. \n# (1)!\n\nKubernetes:\nEnsure that the /etc/hosts file on your physical edge node contains the following entry:\n123.123.123.123 edgefarm-control-plane \n# (2)!\n\nUse this token 123456.0wm9r81m6dlozk30 to join the cluster. You have 1 day to join the cluster before this token expires. \n# (3)!\n\nIf you experience any problems, please consult the documentation at \nhttps://edgefarm.github.io/edgefarm/ or file an issue at https://github.com/edgefarm/edgefarm/issues/new?template=question.md\n</code></pre> <ol> <li>Keep the netbird setup-key for connecting the edge node to the VPN.</li> <li>Add this entry in /etc/hosts. '100.127.213.101' is the VPN IP address of the control-plane node of your local cluster.</li> <li>Keep this token for later to join the node.</li> </ol> <pre><code>$ local-up node join --name eagle --config ~/hetzner-config.yaml \nHere is some information you need to join a edge node to this cluster.\n\nVPN:\nIf you haven't already linked the node to the netbird.io VPN, you must establish the connection to the VPN beforehand.\n\nUse can use this setup-key B0BB22F7-4890-41D7-908A-########### to connect to netbird.io VPN. \n# (1)!\n\nKubernetes:\nUse this token 123456.5emtbddc32xjlplg to join the cluster reachable here: 123.123.123.123:443 \n# (2)!\nYou have 1 day to join the cluster before this token expires.\n\nIf you experience any problems, please consult the documentation at \nhttps://edgefarm.github.io/edgefarm/ or file an issue at https://github.com/edgefarm/edgefarm/issues/new?template=question.md\n</code></pre> <ol> <li>Keep the netbird setup-key for connecting the edge node to the VPN.</li> <li>Keep this token and cluster ip:port for later to join the node.</li> </ol>"},{"location":"knowledge-base/tutorials/cluster/join-ubuntu-22-04-edge-node/#edge-node-preparations","title":"Edge Node preparations","text":"<p>Install Ubuntu Server 22.04 on your target machine. It doesn't matter if you use a Virtual Machine, a Raspberry Pi or any other physical machine.</p> <p>Make sure that you have SSH access to the Pi and that you can log in as root.</p> <p>Install required packages <pre><code>sudo apt update\nsudo apt-get install curl -y\n</code></pre></p>"},{"location":"knowledge-base/tutorials/cluster/join-ubuntu-22-04-edge-node/#run-the-edge-node-prepare-script","title":"Run the Edge Node prepare script","text":"<p>Download the <code>ubuntu-22.04-edge-node-config.tar.gz</code> from the EdgeFarm releases page and extract it on your edge node.</p> <pre><code>$ tar xvfz ubuntu-22.04-edge-node-config.tar.gz\n</code></pre> <p>Run the <code>prepare.sh</code> script as root. This step takes care of the following tasks:</p> <ul> <li>install Docker, socat and conntrack</li> <li>install netbird</li> <li>disable swap</li> <li>setup some udev rules and scripts</li> </ul> <pre><code>./prepare.sh\n</code></pre> <p>Once done, connect netbird using a netbird setup-key. <pre><code>netbird up -k &lt;your token&gt;\n</code></pre></p> <p>You should see the interface <code>wt0</code> using <code>ip a</code> now.</p> <pre><code>$ ip addr show dev wt0\n13: wt0: &lt;POINTOPOINT,NOARP,UP,LOWER_UP&gt; mtu 1280 qdisc noqueue state UNKNOWN group default qlen 1000\n    link/none # (1)!\n    inet 100.127.123.145/16 brd 100.127.255.255 scope global wt0 \n       valid_lft forever preferred_lft forever\n</code></pre> <ol> <li>The IP address is 100.127.123.145</li> </ol>"},{"location":"knowledge-base/tutorials/cluster/join-ubuntu-22-04-edge-node/#join-the-edge-node","title":"Join the Edge Node","text":"Local EdgeFarm clusterCloud Cluster (e.g. Hetzner) <p>Modify the <code>/etc/hosts</code> file on your edge node the way the <code>local-up node join</code>'s output told you. </p> <pre><code>&lt;IP ADDRESS&gt; edgefarm-control-plane # (1)!\n</code></pre> <ol> <li>In the example above, the IP address is <code>100.127.213.101</code>. So your entry must be <code>100.127.213.101 edgefarm-control-plane</code>.</li> </ol> <p>Join the Edge Node to the EdgeFarm cluster by running the <code>install.sh</code> script as root. Use the bootstrap token from the <code>local-up node join</code> output.</p> <pre><code>./install.sh --address edgefarm-control-plane:6443 --token &lt;bootstrap-token&gt; --node-ip $(cat /usr/local/etc/wt0.ip) --join --convert --node-type kubeadm\n</code></pre> <p>Join the Edge Node to the EdgeFarm cluster by running the <code>install.sh</code> script as root. Use the token and ip:port from the <code>local-up node join</code> output.</p> <pre><code>./install.sh --address &lt;ip:port&gt; --token &lt;bootstrap-token&gt; --node-ip $(cat /usr/local/etc/wt0.ip) --join --convert --node-type kubeadm \n</code></pre>"},{"location":"knowledge-base/tutorials/cluster/join-ubuntu-22-04-edge-node/#verify-the-edge-node","title":"Verify the Edge Node","text":"<p>Verify that the Edge Node is ready to use. Let's say the hostname of the node is <code>eagle</code>.</p> <p>Ensure that the envirnment variable <code>KUBECONFIG</code> is set to the kubeconfig file of the EdgeFarm cluster.</p> <pre><code>$ KUBECONFIG=~/.edgefarm-local-up/kubeconfig kubectl get nodes | grep eagle\nNAME     STATUS   ROLES    AGE   VERSION\neagle    Ready    &lt;none&gt;   1M    v1.22.17\n</code></pre>"},{"location":"knowledge-base/tutorials/edgefarm-basics/deploy-an-app/","title":"Deploying an application","text":""},{"location":"knowledge-base/tutorials/edgefarm-basics/deploy-an-app/#objectives","title":"Objectives","text":"<ul> <li>Learn abiout the EdgeFarm application model</li> <li>Deploy your first application with kubectl</li> </ul>"},{"location":"knowledge-base/tutorials/edgefarm-basics/deploy-an-app/#edgefarm-application-model","title":"EdgeFarm application model","text":"<p>Once you have a running EdgeFarm cluster, you can deploy applications to it. To do so, you create a edgefarm.application resource. This resource is a custom resource definition (CRD) that is specific to EdgeFarm. It defines a set of Kubernetes resources that are deployed together as a single unit. The edgefarm.application resource is the primary resource in the EdgeFarm application model, and it represents a single instance of your application. Once you've created an edgefarm.application resource, the Kubernetes control plane schedules the application's Pods to run on your selected nodes.</p>"},{"location":"knowledge-base/tutorials/edgefarm-basics/deploy-an-app/#writing-the-manifest","title":"Writing the manifest","text":"<p>The edgefarm.application resource is a Kubernetes custom resource. You can create it by writing a manifest file that describes the resource. The manifest file is a YAML file that contains the edgefarm.application resource definition. The following example shows a manifest file that creates an edgefarm.application resource.  See the edgefarm.application reference for a complete description of the edgefarm.application resource.</p> <p>Let's create a file called <code>basic.yaml</code> and add the following content: <pre><code>apiVersion: core.oam.dev/v1beta1\nkind: Application\nmetadata:\n  name: kubernetes-bootcamp\n  namespace: default\nspec:\n  components:\n    - name: kubernetes-bootcamp\n      type: edgefarm-applications \n      properties:\n        image: gcr.io/google-samples/kubernetes-bootcamp:v1 #(1)!\n        nodepoolSelector:\n          matchLabels:\n            bootcamp: \"true\" #(2)!\n</code></pre></p> <ol> <li>We'll deploy the kubernetes-bootstrap OCI image. This is a simple webserver that will be deployed to the cluster.</li> <li>We'll deploy to nodepools that have the label <code>bootcamp=true</code>. This label will be added in the next few steps.</li> </ol>"},{"location":"knowledge-base/tutorials/edgefarm-basics/deploy-an-app/#deploying-the-manifest","title":"Deploying the manifest","text":"<p>To view the Edge Nodes in the cluster, run the <code>kubectl get nodes -l openyurt.io/is-edge-worker=true</code> command.</p> <p>You see the available edge nodes. Later, we will choose where to deploy our application based on Node available resources.</p> <pre><code>$ kubectl get nodes -l openyurt.io/is-edge-worker=true\nNAME               STATUS   ROLES    AGE    VERSION\nedgefarm-worker2   Ready    &lt;none&gt;   9m2s   v1.22.7\nedgefarm-worker3   Ready    &lt;none&gt;   9m3s   v1.22.7\n\n$ kubectl get nodepools                 \nNAME               TYPE   READYNODES   NOTREADYNODES   AGE\nedgefarm-worker2   Edge   1            0               9m5s\nedgefarm-worker3   Edge   1            0               9m5s\n</code></pre> <p>Note</p> <p>Every Edge Node is mapped to a corresponding nodepool. This can be seen as a 1:1 relationship. Via labels on the nodepool, we can control which applications are deployed to which node.</p> <p>Now let's deploy the application and label a nodepool as <code>bootcamp=true</code>.</p> <pre><code>$ kubectl apply -f basic.yaml #(1)!\napplication.core.oam.dev/kubernetes-bootcamp created\n\n$ kubectl label nodepools.apps.openyurt.io edgefarm-worker3 bootcamp=true #(2)!\nnodepool.apps.openyurt.io/edgefarm-worker3 labeled\n\n$ kubectl get deployments.apps #(3)!\nNAME                                         READY   UP-TO-DATE   AVAILABLE   AGE\nkubernetes-bootcamp-edgefarm-worker3-8krt7   1/1     1            1           21s\n\n$ kubectl get pods -o wide #(4)!                   \nNAME                                                          READY   STATUS    RESTARTS   AGE   IP           NODE              NOMINATED NODE   READINESS GATES\nkubernetes-bootcamp-edgefarm-worker3-8krt7-6b4fc49596-56f2h   1/1     Running   0          37s   10.244.2.5   edgefarm-worker3   &lt;none&gt;           &lt;none&gt;\n</code></pre> <ol> <li>We deploy the application</li> <li>We label the nodepool <code>edgefarm-worker3</code> as <code>bootcamp=true</code></li> <li>We see that the deployment on node <code>edgefarm-worker3</code> was successful</li> <li>We see that the pod is running on node <code>edgefarm-worker3</code></li> </ol>"},{"location":"knowledge-base/tutorials/edgefarm-basics/deploy-an-app/#testing-the-application","title":"Testing the application","text":"<p>Now, let's test the application. We'll use the <code>kubectl exec</code> command to run a command in the pod and print its output.</p> <pre><code>$ kubectl exec -it kubernetes-bootcamp-edgefarm-worker3-8krt7-6b4fc49596-56f2h -- curl http://localhost:8080/version\nHello Kubernetes bootcamp! | Running on: kubernetes-bootcamp-edgefarm-worker3-8krt7-6b4fc49596-56f2h | v=1\n</code></pre> <p>Great! The application is running. You've learned how to deploy an application and to control where it will be deployed.</p>"},{"location":"pricing/","title":"Pricing","text":""},{"location":"pricing/#pricing","title":"Pricing","text":"<p>We offer EdgeFarm as PaaS (Platform as a Service) for you to build your own IoT applications. </p> <p>Please contact us at info@ci4rail.com! We will be happy to discuss your requirements and provide you with a quote.</p>"},{"location":"usecases/usecases/","title":"Use Cases","text":"<p>EdgeFarm is a general purpose development platform for edge scenarios. Accordingly, a variety of use cases can be implemented with EdgeFarm.</p> <p>What makes EdgeFarm different from other solutions is not only that I can implement the users specific use case, but that you can implement it easily and conveniently and maintain it after implementation.</p> <p>The following (incomplete) list should give an idea what EdgeFarm can be used for.</p>"},{"location":"usecases/usecases/#read-out-sensors-or-control-actors","title":"Read out sensors or control actors","text":"<p>This is one of the simplest and most common use cases. There are sensors that are accessible by a device using local protocols. However, the data of these sensors need to be distributed to a completely different location, e.g. a cloud system. </p> <p>The required application is developed locally on the developers machine and can then be deployed, packaged in a container, with edgefarm.applications to the appropriate edge device with access to the sensors. The transport of my collected data is handled by edgefarm.network.</p>"},{"location":"usecases/usecases/#connecting-existing-air-gapped-systems","title":"Connecting existing air-gapped systems","text":"<p>Let's assume there is a fully functional system that has been developed elaborately and is doing its job. This system generates data that can only be read locally. However, this generated data would be very interesting to know in the meantime.</p> <p>In this case EdgeFarm can be used to digitalize the device afterwards. For this the edgefarm-ready device  is connected with the target hardware. From this point one can access the target hardware at any time and digitize it bit by bit.</p>"},{"location":"usecases/usecases/#optimize-application-performance","title":"Optimize application performance","text":"<p>Changes to the firmware of an embedded device are often quite complex. Thus, developers tend to implement as much functionality as possible in the application - even not needed functionality that is used current use case. This leads to a situation where the application simply is too complex for the current use case and tends to transfer data that is not needed.</p> <p>Due to the separation of EdgeFarm into firmware updates and application updates, individual application components can be changed or delivered at any time. This allows to react to new requirements at any time and enrich, convert or expand data. Only the data that is actually needed should be transferred.</p>"},{"location":"usecases/usecases/#deploy-multiple-applications","title":"Deploy Multiple Applications","text":"<p>EdgeFarm has the ability to run multiple applications on one edge device. These applications are isolated from each other and their resources can be limited.</p> <p>This means that different groups of people can run different applications on the devices, each of which implements its own use cases. The edge device becomes an application platform.</p>"},{"location":"usecases/usecases/#preprocess-data-before-sending-it-to-the-cloud","title":"Preprocess data before sending it to the cloud","text":"<p>Sometimes it is necessary to preprocess data before sending it to the cloud. The preprocessing can be done in the application running on the edge devices and could use a lot of data, preprocess it and send only single events using edgefarm.network. As for preprocessing, a simple algorithm or a complex AI model can be used. That is completely application specific and up to the developer. </p> <p>Preprocessing at the edge can drastically reduce the amount of data to be transmitted.</p>"}]}